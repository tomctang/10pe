
<!DOCTYPE html>


<html lang="en" data-content_root="../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>A) Data Structures Applications &#8212; Jonny Workbook</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />

  
  <link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=03e43079" />
    <link rel="stylesheet" type="text/css" href="../_static/styles/sphinx-book-theme.css?v=eba8b062" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css?v=13237357" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.8ecb98da25f57f5357bf6f572d296f466b2cfe2517ffebfabe82451661e28f02.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css?v=4fa983c6" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-design.min.css?v=95c83b7e" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=8dedbda2" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" />
<link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" />
  <script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>

    <script src="../_static/documentation_options.js?v=9eb32ce0"></script>
    <script src="../_static/doctools.js?v=9a2dae69"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../_static/copybutton.js?v=f281be69"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js?v=4a39c7ea"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../_static/design-tabs.js?v=f930bc37"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script async="async" src="../_static/sphinx-thebe.js?v=c100c467"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"; const thebe_selector = ".thebe,.cell"; const thebe_selector_input = "pre"; const thebe_selector_output = ".output, .cell_output"</script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'PE_Informatics/codingall';</script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-primary-sidebar-checkbox"/>
  <label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          id="pst-secondary-sidebar-checkbox"/>
  <label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../intro.html">
  
  
  
  
  
  
    <p class="title logo__title">Jonny Workbook</p>
  
</a></div>
        <div class="sidebar-primary-item">

 <script>
 document.write(`
   <button class="btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro.html">
                    Introduction
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Mathe &amp; FP/Language</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../Alevel/Alevel_math.html">1. A-level-math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Alevel/Alevel_math_further.html">2. A-level-further</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Course_MCM.html">3. Math Computational Methods</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Course_Lean.html">4. Lean</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/00intro_math.html">5. Math-FP-Lang Combo</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/01number_algebra.html">6. Number &amp; Algebra</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/02discrete_continuous.html">7. Discrete &amp; Continuous</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/03real_world.html">8. Real World Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="../math/05math_as_code.html">9. Math as code</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">CS &amp; Physics</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../Course_MIT6001Python.html">10. MIT_CS6001-Python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Course_MIT6002thinking.html">11. MIT_CS6002-CS</a></li>
<li class="toctree-l1"><a class="reference internal" href="PE_tags.html">12. Project Euler Tags</a></li>
<li class="toctree-l1"><a class="reference internal" href="PE_math.html">13. Project Euler Math</a></li>
<li class="toctree-l1"><a class="reference internal" href="PE50.html">14. Project Euler Q1-50</a></li>
<li class="toctree-l1"><a class="reference internal" href="PE100.html">15. Project Euler Q51-</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Course_MCM_QM.html">16. Quantum Mechanics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../How_Dad_organise_QM.html">17. How Dad learn QM</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Course_MCM_QFT.html">18. QFT</a></li>
</ul>
<p aria-level="2" class="caption" role="heading"><span class="caption-text">Notebook</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../nb_past_courses.html">19. Past courses</a></li>
<li class="toctree-l1"><a class="reference internal" href="../geo/nb_Geo.html">20. Geography and Maps</a></li>
<li class="toctree-l1"><a class="reference internal" href="../nb_lottery_simulator.html">21. Lottery Math</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/tomctang/10pe" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../_sources/PE_Informatics/codingall.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm pst-navbar-icon search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<button class="sidebar-toggle secondary-toggle btn btn-sm" title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</button>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>A) Data Structures Applications</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">A) Data Structures Applications</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#binary-search-tree-algorithm">Binary Search Tree Algorithm</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#b-string-algorithm">B) String Algorithm</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#suffix-tree-suffix-array">Suffix Tree - Suffix Array</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#c-searching-and-graph-algorithms">C) Searching and Graph Algorithms</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#graph-theory">Graph Theory</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#detect-cycle">Detect Cycle</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#graph-traversal">Graph Traversal</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-spanning-tree-mst">Minimum Spanning Tree (MST)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#shortest-path">Shortest Path</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#d-greedy-algorithm">D) Greedy Algorithm</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#e-dynamic-programming">E) Dynamic Programming</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#coin-change-algorithms">Coin Change Algorithms</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#knapsack-problems">Knapsack Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#path-sum-problems">Path Sum Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#subarray-problems">Subarray Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#subsequence-problems">Subsequence Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#substring-problems">Substring Problems</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#f-two-pointers-sliding-window">F) Two Pointers - Sliding Window</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#non-categorized">Non-categorized</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#visualization-of-how-the-algorithm-works">Visualization of how the algorithm works</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#g-mathematics">G) Mathematics</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#binomial-coefficient-problems">Binomial Coefficient Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#factors-problems">Factors Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multiples-problems">Multiples Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#permutation-problems">Permutation Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#primes-problems">Primes Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#primes-factors-problems">Primes-Factors Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pythagorean-theorem">Pythagorean Theorem</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Non-categorized</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#h-linked-list">H) Linked List</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#singly-linked-list">Singly-linked List</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#i-matrix">I) Matrix</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#matrix-x-simulation">Matrix x Simulation</a></li>
</ul>
</li>
</ul>

            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <img src="https://raw.githubusercontent.com/tomctang/NB_img/main/codingall.png" alt="vector_cal" width="550">
<p><strong>Tips &amp; Tricks</strong></p>
<p>If input array is sorted then</p>
<ul class="simple">
<li><p>Binary search</p></li>
<li><p>Two pointers</p></li>
</ul>
<p>If asked for all permutations/subsets then</p>
<ul class="simple">
<li><p>Backtracking</p></li>
</ul>
<p>If given a tree then</p>
<ul class="simple">
<li><p>DFS</p></li>
<li><p>BFS</p></li>
</ul>
<p>If given a graph then</p>
<ul class="simple">
<li><p>DFS</p></li>
<li><p>BFS</p></li>
</ul>
<p>If given a linked list then</p>
<ul class="simple">
<li><p>Two pointers</p></li>
</ul>
<p>If recursion is banned then</p>
<ul class="simple">
<li><p>Stack</p></li>
</ul>
<p>If must solve in-place then</p>
<ul class="simple">
<li><p>Swap corresponding values</p></li>
<li><p>Store one or more different values in the same pointer</p></li>
</ul>
<p>If asked for maximum/minumum subarray/subset/options then</p>
<ul class="simple">
<li><p>Dynamic programming</p></li>
</ul>
<p>If asked for top/least K items then</p>
<ul class="simple">
<li><p>Heap</p></li>
</ul>
<p>If asked for common strings then</p>
<ul class="simple">
<li><p>Map</p></li>
<li><p>Trie</p></li>
</ul>
<p>Else</p>
<ul class="simple">
<li><p>Map/Set for O(1) time &amp; O(n) space</p></li>
<li><p>Sort input for O(nlogn) time and O(1) space</p></li>
</ul>
<section id="a-data-structures-applications">
<h1>A) Data Structures Applications<a class="headerlink" href="#a-data-structures-applications" title="Link to this heading">#</a></h1>
<section id="binary-search-tree-algorithm">
<h2>Binary Search Tree Algorithm<a class="headerlink" href="#binary-search-tree-algorithm" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Data%20Structures%20Applications/BST.ipynb"><span class="xref myst">Binary Search Tree</span></a>: Original Binary Search Tree Algorithm - <strong>O(log(n))</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Data%20Structures%20Applications/BST_Find.ipynb"><span class="xref myst">Binary Search Tree: Check a Number</span></a>: Check if a Number is in a Sorted List using BST Algorithm - <strong>O(log(n))</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Data%20Structures%20Applications/BST_Find_Index.ipynb"><span class="xref myst">Binary Search Tree: Index of a Number</span></a>: Find the Index of a Number in a Sorted List using BST Algorithm - <strong>O(log(n))</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Original Binary Search Tree Algorithm</span>
<span class="sd">  Time complexity = O(logn)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    sortedList: list</span>
<span class="sd">                A sorted list of numbers as the input </span>
<span class="sd">    n         : integer</span>
<span class="sd">                The number to find the index</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    idx: intger</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; l = [1, 3, 5, 6, 7, 10]</span>
<span class="sd">    &gt;&gt;&gt; print(BST(l, 5))</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; print(BST(l, 8))</span>
<span class="sd">    Exception: n is not in the list</span>

<span class="sd">  References:</span>
<span class="sd">    https://www.geeksforgeeks.org/binary-search/</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">BST</span><span class="p">(</span><span class="n">sortedList</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span> 
  <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">arr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedList</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sortedList</span>

  <span class="k">while</span> <span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">:</span> 
    <span class="n">m</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="c1"># Mid      </span>
    <span class="c1"># Check if n is present at mid </span>
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span> 
      <span class="k">return</span> <span class="n">m</span> 
    <span class="c1"># If n is greater, ignore left half </span>
    <span class="k">elif</span> <span class="n">arr</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span> 
      <span class="n">l</span> <span class="o">=</span> <span class="n">m</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="c1"># If n is smaller, ignore right half </span>
    <span class="k">else</span><span class="p">:</span> 
      <span class="n">r</span> <span class="o">=</span> <span class="n">m</span> <span class="o">-</span> <span class="mi">1</span>
      
  <span class="c1"># If we reach here, then the element was not present </span>
  <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;n is not in the list&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to check if a number is in a sorted list using Binary Search Tree Algorithm</span>
<span class="sd">  Time complexity = O(logn)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    sortedList: list</span>
<span class="sd">                A sorted list of numbers as the input </span>
<span class="sd">    n         : integer</span>
<span class="sd">                The number to find</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    True/False: boolean</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; l = [1, 3, 5, 6, 7, 10]</span>
<span class="sd">    &gt;&gt;&gt; print(BST_Find(l,3))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; print(BST_Find(l,8))</span>
<span class="sd">    False</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">bisect</span><span class="w"> </span><span class="kn">import</span> <span class="n">bisect_left</span>

<span class="k">def</span><span class="w"> </span><span class="nf">BST_Find</span><span class="p">(</span><span class="n">sortedList</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">sortedList</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedList</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sortedList</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">True</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find the index of a number in a sorted list using Binary Search Tree Algorithm</span>
<span class="sd">  Time complexity = O(logn)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    sortedList: list</span>
<span class="sd">                A sorted list of numbers as the input </span>
<span class="sd">    n         : integer</span>
<span class="sd">                The number to find the index</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    idx: intger</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; l = [1, 3, 5, 6, 7, 10]</span>
<span class="sd">    &gt;&gt;&gt; print(BST_Find_Index(l,5))</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; print(BST_Find_Index(l,8))</span>
<span class="sd">    Exception: n is not in the list</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">bisect</span><span class="w"> </span><span class="kn">import</span> <span class="n">bisect_left</span>

<span class="k">def</span><span class="w"> </span><span class="nf">BST_Find_Index</span><span class="p">(</span><span class="n">sortedList</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
  <span class="n">idx</span> <span class="o">=</span> <span class="n">bisect_left</span><span class="p">(</span><span class="n">sortedList</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedList</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sortedList</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">idx</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;n is not in the list&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
</section>
</section>
<section id="b-string-algorithm">
<h1>B) String Algorithm<a class="headerlink" href="#b-string-algorithm" title="Link to this heading">#</a></h1>
<section id="suffix-tree-suffix-array">
<h2>Suffix Tree - Suffix Array<a class="headerlink" href="#suffix-tree-suffix-array" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/String%20Algorithm/SuffixArray_ManberMyers.ipynb"><span class="xref myst">Suffix Array (Manber-Myers Algorithm)</span></a>: Find suffix array of a string S based on Manber-Myers algorithm - <strong>O(n.log(n))</strong> , n = |S|</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/String%20Algorithm/LCPArray_Kasai.ipynb"><span class="xref myst">Longest Common Prefix Array (Kasai Algorithm)</span></a>: Find longest common prefix array of a string S with the help of suffix array based on Kasai algorithm - <strong>O(n)</strong> , n = |S|</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="disabled" type="checkbox"> Longest Palindromic Substring - <strong>O(n)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="disabled" type="checkbox"> Pattern Search - <strong>O(log(n))</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find Suffix Array of a string based on Manber-Myers algorithm</span>
<span class="sd">  Time complexity = O(n.log(n))</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    s: string</span>
<span class="sd">       Input string to convert into suffix array </span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    sa: list</span>
<span class="sd">        Suffix array of the input string</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">      Let the given string be &quot;banana&quot;.</span>

<span class="sd">    0 banana                          5 a</span>
<span class="sd">    1 anana     Sort the Suffixes     3 ana</span>
<span class="sd">    2 nana      ----------------&gt;     1 anana  </span>
<span class="sd">    3 ana        alphabetically       0 banana  </span>
<span class="sd">    4 na                              4 na   </span>
<span class="sd">    5 a                               2 nana</span>

<span class="sd">    So the suffix array for &quot;banana&quot; is [5, 3, 1, 0, 4, 2]</span>

<span class="sd">    &gt;&gt;&gt; s = &#39;banana&#39;</span>
<span class="sd">    &gt;&gt;&gt; sa = SuffixArray_ManberMyers(s)</span>
<span class="sd">    &gt;&gt;&gt; print(sa)</span>
<span class="sd">    [5, 3, 1, 0, 4, 2]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">def</span><span class="w"> </span><span class="nf">SuffixArray_ManberMyers</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
  <span class="c1"># Using Bucket Sort instead of built-in &quot;sorted&quot; can save space when dealing</span>
  <span class="c1"># with very big input string</span>
  <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">Bucket_Sort</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">bucket</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">bucket</span><span class="p">:</span>
      <span class="n">key</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">order</span><span class="p">]</span>
      <span class="n">d</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
      <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">Bucket_Sort</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">order</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">result</span>

  <span class="n">sa</span> <span class="o">=</span> <span class="n">Bucket_Sort</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))))</span> <span class="c1"># Suffix array</span>
  <span class="k">return</span> <span class="n">sa</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find Longest Common Prefix Array based on Kasai algorithm</span>
<span class="sd">  Time complexity = O(n)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    s : string</span>
<span class="sd">        Input string to convert into suffix array </span>
<span class="sd">    sa: list</span>
<span class="sd">        Suffix array of the input string</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    l: list</span>
<span class="sd">       Longest Common Prefix Array</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">      Let the given string be &quot;banana&quot;.</span>
<span class="sd">                                 Suffix    LCP</span>
<span class="sd">    0 banana                     5 a        0</span>
<span class="sd">    1 anana   Sort the Suffixes  3 ana      1</span>
<span class="sd">    2 nana    ----------------&gt;  1 anana    3</span>
<span class="sd">    3 ana      alphabetically    0 banana   0</span>
<span class="sd">    4 na                         4 na       0</span>
<span class="sd">    5 a                          2 nana     2</span>

<span class="sd">    The suffix array for &quot;banana&quot; is [5, 3, 1, 0, 4, 2]</span>
<span class="sd">    The LCP array is [0, 1, 3, 0, 0, 2]</span>

<span class="sd">    &gt;&gt;&gt; s = &#39;banana&#39;</span>
<span class="sd">    &gt;&gt;&gt; sa = SuffixArray_ManberMyers(s)</span>
<span class="sd">    &gt;&gt;&gt; print(LCPArray_Kasai(s, sa))</span>
<span class="sd">    [0, 1, 3, 0, 0, 2]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">LCPArray_Kasai</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sa</span><span class="p">):</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
  <span class="n">lcp</span><span class="p">,</span> <span class="n">ra</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">ra</span><span class="p">[</span><span class="n">sa</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>
  <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">ra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
      <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
      <span class="k">continue</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">sa</span><span class="p">[</span><span class="n">ra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">k</span><span class="p">]:</span>
      <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">lcp</span><span class="p">[</span><span class="n">ra</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">k</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>
  <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">l</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">lcp</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">l</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
</section>
</section>
<section id="c-searching-and-graph-algorithms">
<h1>C) Searching and Graph Algorithms<a class="headerlink" href="#c-searching-and-graph-algorithms" title="Link to this heading">#</a></h1>
<section id="graph-theory">
<h2>Graph Theory<a class="headerlink" href="#graph-theory" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Searching%20and%20Graph%20Algorithms/Graph_AdjacencyList.ipynb"><span class="xref myst">Graph Representation using Adjacency List: Unweighted, Un-/Directed</span></a>: Create a Unweighted Un-/Directed Graph using Adjacency List</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="disabled" type="checkbox"> Graph Representation using Adjacency List: Weighted, Un-/Directed</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Searching%20and%20Graph%20Algorithms/Find_AllNodes.ipynb"><span class="xref myst">Find All Nodes</span></a>: Find All Nodes in the Unweighted Graph - <strong>O(V+E) for Adjacency List</strong> , V, E is the number of vertices and edges</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="disabled" type="checkbox"> Find All Edges</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Searching%20and%20Graph%20Algorithms/Find_AllPaths_BFS.ipynb"><span class="xref myst">Find All Paths between 2 Nodes</span></a>: Find All Paths between 2 Nodes in a Unweighted Graph using BFS - <strong>NP-Hard</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Searching%20and%20Graph%20Algorithms/DisjointSet.ipynb"><span class="xref myst">Disjoint Set (Union-Find): Union by Rank and Path Compression</span></a>: Create a Disjoint Set (Union-Find) using “Union by Rank and Path Compression” for an Undirected Graph (used to Detect Cycle) - <strong>Time = O(small constant), Space = O(V)</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Class to create a Unweighted Un-/Directed Graph using Adjacency List</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    u, v: integer, string</span>
<span class="sd">          Name of starting and ending vertex</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    self.graph: defaultdict</span>
<span class="sd">                Graph, each starting vertex as key is a list of ending vertices</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; g = Graph()</span>
<span class="sd">    &gt;&gt;&gt; g.addEdge(1, 2)</span>
<span class="sd">    &gt;&gt;&gt; g.addEdge(1, 3)</span>
<span class="sd">    &gt;&gt;&gt; g.addEdge(4, 5)</span>
<span class="sd">    &gt;&gt;&gt; g.addEdge(6, None)</span>
<span class="sd">    &gt;&gt;&gt; print(g.graph)</span>
<span class="sd">    defaultdict(&lt;class &#39;list&#39;&gt;, {1: [2, 3], 4: [5], 6: []})</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Graph</span><span class="p">:</span> 
  <span class="c1"># Constructor </span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> 
    <span class="c1"># Default dictionary to store graph </span>
    <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> 
  
  <span class="c1"># Function to add an edge to graph </span>
  <span class="k">def</span><span class="w"> </span><span class="nf">addEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">):</span> 
    <span class="c1"># In case of disconnected graph</span>
    <span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span>
    <span class="c1"># In case of connected graph</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
      <span class="c1"># In case of undirected graph</span>
      <span class="c1">#self.graph[v].append(u)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find all nodes in the graph</span>
<span class="sd">  Time complexity = O(V+E) for Adjacency List</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    graph: defaultdict</span>
<span class="sd">           Graph, each starting vertex as a key is a list of ending vertices</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    AllNodes: set</span>
<span class="sd">              A set of all nodes in the graph</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; graph = {0: [1, 3], 1: [2], 3: [4, 7], 4: [5, 6, 7], 5: [6], 6: [7]}</span>
<span class="sd">    &gt;&gt;&gt; print(Find_AllNodes(graph))</span>
<span class="sd">    {0, 1, 2, 3, 4, 5, 6, 7}</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Find_AllNodes</span><span class="p">(</span><span class="n">graph</span><span class="p">):</span>  
  <span class="n">AllNodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
  <span class="k">for</span> <span class="n">values</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
      <span class="n">AllNodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">AllNodes</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find all paths between 2 nodes in a graph using BFS</span>
<span class="sd">  Time complexity = NP-Hard</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    graph: defaultdict</span>
<span class="sd">           Graph, each starting vertex as a key is a list of ending vertices</span>
<span class="sd">    start: integer, string</span>
<span class="sd">           Starting vertex of the path</span>
<span class="sd">    end  : integer, string</span>
<span class="sd">           Ending vertex of the path</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    AllPaths: list</span>
<span class="sd">              A list of all paths between 2 nodes in a graph</span>


<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; graph = {0: [1, 3], 1: [2], 2: [], 3: [4, 7], 4: [5, 6, 7], 5: [6], 6: [7]}</span>
<span class="sd">    &gt;&gt;&gt; print(Find_AllPaths_BFS(graph, 0, 7))</span>
<span class="sd">    [[0, 3, 7], [0, 3, 4, 7], [0, 3, 4, 6, 7], [0, 3, 4, 5, 6, 7]]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Find_AllPaths_BFS</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="p">[</span><span class="n">start</span><span class="p">])]</span>
  <span class="n">AllPaths</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
    <span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">next</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">vertex</span><span class="p">])</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">next</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>
        <span class="n">AllPaths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="nb">next</span><span class="p">])</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">next</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="nb">next</span><span class="p">]))</span>
  <span class="k">return</span> <span class="n">AllPaths</span>

<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">2</span><span class="p">:</span> <span class="p">[],</span> <span class="mi">3</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">4</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="mi">5</span><span class="p">:</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="mi">6</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">]}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">Find_AllPaths_BFS</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to create a disjoint set (union-find) using &quot;union by rank and path compression&quot;</span>
<span class="sd">    for an undirected graph (used to detect cycle)</span>
<span class="sd">  Time complexity = O(small constant)</span>
<span class="sd">  Space complexity = O(V)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    graph: defaultdict</span>
<span class="sd">           Graph, each starting vertex as a key is a list of ending vertices</span>
<span class="sd">    V    : integer</span>
<span class="sd">           Number of vertex</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    subsets: list</span>
<span class="sd">             A list of V subsets</span>

<span class="sd">  Examples:</span>
<span class="sd">  --------- </span>
<span class="sd">    &gt;&gt;&gt; graph = {0: [1, 2], 1: [2]}</span>
<span class="sd">    &gt;&gt;&gt; print(DisjointSet(graph, 3))</span>
<span class="sd">    [{&#39;parent&#39;: 0, &#39;rank&#39;: 2}, {&#39;parent&#39;: 0, &#39;rank&#39;: 0}, {&#39;parent&#39;: 0, &#39;rank&#39;: 0}]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">DisjointSet</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
  <span class="c1"># Function to create a subset of element nodes</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">DisjointSet_Subset</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
    <span class="n">subset</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;parent&#39;</span><span class="p">:</span> <span class="n">parent</span><span class="p">,</span> <span class="s1">&#39;rank&#39;</span><span class="p">:</span> <span class="n">rank</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">subset</span>

  <span class="c1"># Function to find subset of an element node (uses path compression technique)</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">DisjointSet_Find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node</span><span class="p">:</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DisjointSet_Find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span>
  
  <span class="c1"># Function that does union of two subsets of u and v (uses union by rank)</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">DisjointSet_Union</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="c1"># Attach smaller rank tree under root of high rank tree (Union by Rank)</span>
    <span class="k">if</span> <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]:</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
    <span class="k">elif</span> <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]:</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="c1"># If ranks are same, then make one as root and increment its rank by one</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="c1"># Main function</span>
  <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span> 
  <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
    <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DisjointSet_Subset</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    
  <span class="c1"># Iterate through all edges of graph, find subsets of both vertices of </span>
  <span class="c1"># every edge, then do union of 2 subsets</span>
  <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
    <span class="n">u_rep</span> <span class="o">=</span> <span class="n">DisjointSet_Find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="c1"># Representative node of u</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
      <span class="n">v_rep</span> <span class="o">=</span> <span class="n">DisjointSet_Find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="c1"># Representative node of v</span>
      <span class="n">DisjointSet_Union</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">u_rep</span><span class="p">,</span> <span class="n">v_rep</span><span class="p">)</span>
 
  <span class="k">return</span> <span class="n">subsets</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="detect-cycle">
<h2>Detect Cycle<a class="headerlink" href="#detect-cycle" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="7">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Searching%20and%20Graph%20Algorithms/isCycle_DisjointSet.ipynb"><span class="xref myst">Detect Cycle: Disjoint Set</span></a>: Detect Cycle in an Undirected Graph based on Disjoint Set (Union-Find) using “Union by Rank and Path Compression” - <strong>O(V)</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to detect cycle in an undirected graph based on disjoint set (union-find) </span>
<span class="sd">    using &quot;union by rank and path compression&quot;</span>
<span class="sd">  Time complexity = O(V)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    graph: defaultdict</span>
<span class="sd">           Graph, each starting vertex as a key is a list of ending vertices</span>
<span class="sd">    V    : integer</span>
<span class="sd">           Number of vertex</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    True/False: boolean</span>

<span class="sd">  Examples:</span>
<span class="sd">  --------- </span>
<span class="sd">    &gt;&gt;&gt; graph = {0: [1, 2], 1: [2]}</span>
<span class="sd">    &gt;&gt;&gt; print(isCycle_DisjointSet(graph, 3))</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; graph = {0: [1], 1: [2]}</span>
<span class="sd">    &gt;&gt;&gt; print(isCycle_DisjointSet(graph, 3))</span>
<span class="sd">    False</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">isCycle_DisjointSet</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
  <span class="c1"># Function to create a subset of element nodes</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">DisjointSet_Subset</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
    <span class="n">subset</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;parent&#39;</span><span class="p">:</span> <span class="n">parent</span><span class="p">,</span> <span class="s1">&#39;rank&#39;</span><span class="p">:</span> <span class="n">rank</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">subset</span>

  <span class="c1"># Function to find subset of an element node (uses path compression technique)</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">DisjointSet_Find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node</span><span class="p">:</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DisjointSet_Find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span>
  
  <span class="c1"># Function that does union of two subsets of u and v (uses union by rank)</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">DisjointSet_Union</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="c1"># Attach smaller rank tree under root of high rank tree (Union by Rank)</span>
    <span class="k">if</span> <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]:</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
    <span class="k">elif</span> <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]:</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="c1"># If ranks are same, then make one as root and increment its rank by one</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="c1"># Main function</span>
  <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span> 
  <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
    <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DisjointSet_Subset</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    
  <span class="c1"># Iterate through all edges of graph, find subsets of both vertices of </span>
  <span class="c1"># every edge. If sets are same, then there is cycle in graph.</span>
  <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
    <span class="n">u_rep</span> <span class="o">=</span> <span class="n">DisjointSet_Find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span> <span class="c1"># Representative node of u</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
      <span class="n">v_rep</span> <span class="o">=</span> <span class="n">DisjointSet_Find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="c1"># Representative node of v</span>
      <span class="c1"># Detect cycle   </span>
      <span class="k">if</span> <span class="n">u_rep</span> <span class="o">==</span> <span class="n">v_rep</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>
      <span class="c1"># Do union of 2 subsets</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">DisjointSet_Union</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">u_rep</span><span class="p">,</span> <span class="n">v_rep</span><span class="p">)</span>
  <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="graph-traversal">
<h2>Graph Traversal<a class="headerlink" href="#graph-traversal" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="8">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Searching%20and%20Graph%20Algorithms/BFS.ipynb"><span class="xref myst">Breadth-First Search</span></a>: Find BFS Path from a Starting Node in Un-/Directed Graph - <strong>O(V+E) for Adjacency List; O(V<sup>2</sup>) for Adjacency Matrix</strong> , V, E is the number of vertices and edges</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Searching%20and%20Graph%20Algorithms/DFS.ipynb"><span class="xref myst">Depth-First Search</span></a>: Find DFS Path from a Starting Node in Un-/Directed Graph - <strong>O(V+E) for Adjacency List; O(V<sup>2</sup>) for Adjacency Matrix</strong> , V, E is the number of vertices and edges</p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find Breadth-First Search path from a source node in un-/directed graph</span>
<span class="sd">  Time complexity = O(V+E) for Adjacency List</span>
<span class="sd">  Time complexity = O(V^2) for Adjacency Matrix</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    graph: defaultdict</span>
<span class="sd">           Graph, each starting vertex as a key is a list of ending vertices</span>
<span class="sd">    V    : integer</span>
<span class="sd">           Number of vertices</span>
<span class="sd">    src  : integer</span>
<span class="sd">           Starting vertex of the BFS path</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    path: list</span>
<span class="sd">          BFS path, contains all nodes on the path</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}</span>
<span class="sd">    &gt;&gt;&gt; V = 4</span>
<span class="sd">    &gt;&gt;&gt; src = 2</span>
<span class="sd">    &gt;&gt;&gt; print(BFS(graph, V, src))</span>
<span class="sd">    [2, 0, 3, 1]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">BFS</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span> 
  <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="n">V</span> <span class="c1"># Mark all verices as not visited </span>
  <span class="n">queue</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Create a queue for BFS</span>
  <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="c1"># Push the current source node</span>
  <span class="n">visited</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Mark the source node as visited</span>
  <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Create BFS path</span>

  <span class="k">while</span> <span class="n">queue</span><span class="p">:</span> 
    <span class="c1"># Pop a vertex from queue and put into path</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="c1"># Get all adjacent vertices of the popped vertex u. If a adjacent </span>
    <span class="c1"># has not been visited, then mark it as visited and put into the queue </span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>  
      <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span> 
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> 
        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

  <span class="k">return</span> <span class="n">path</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find Depth-First Search path from a source node in un-/directed graph</span>
<span class="sd">  Time complexity = O(V+E) for Adjacency List</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    graph: defaultdict</span>
<span class="sd">           Graph, each starting vertex as a key is a list of ending vertices</span>
<span class="sd">    V    : integer</span>
<span class="sd">           Number of vertices</span>
<span class="sd">    src  : integer</span>
<span class="sd">           Starting vertex of the DFS path</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    path: list</span>
<span class="sd">          DFS path, contains all nodes on the path</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; graph = {0: [1, 2], 1: [2], 2: [0, 3], 3: [3]}</span>
<span class="sd">    &gt;&gt;&gt; V = 4</span>
<span class="sd">    &gt;&gt;&gt; src = 2</span>
<span class="sd">    &gt;&gt;&gt; print(DFS(graph, V, src))</span>
<span class="sd">    [2, 3, 0, 1]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">DFS</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">src</span><span class="p">):</span>            
  <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="n">V</span> <span class="c1"># Mark all verices as not visited </span>
  <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Create a stack for DFS </span>
  <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="c1"># Push the current source node</span>
  <span class="n">visited</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># Mark the source node as visited</span>
  <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Create DFS path</span>

  <span class="k">while</span> <span class="n">stack</span><span class="p">:</span> 
    <span class="c1"># Pop a vertex from stack and put into path</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="c1"># Get all adjacent vertices of the popped vertex u. If a adjacent </span>
    <span class="c1"># has not been visited, then mark it as visited and put into the stack</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span> 
      <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span> 
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> 
        <span class="n">visited</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

  <span class="k">return</span> <span class="n">path</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="minimum-spanning-tree-mst">
<h2>Minimum Spanning Tree (MST)<a class="headerlink" href="#minimum-spanning-tree-mst" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="10">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Searching%20and%20Graph%20Algorithms/MST_Prim.ipynb"><span class="xref myst">MST: Prim Algorithm</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/MST_Prim.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find Minimum Spanning Tree (MST) of an Undirected Graph using Prim Algorithm - <strong>O(E.log(V))</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Searching%20and%20Graph%20Algorithms/MST_Kruskal.ipynb"><span class="xref myst">MST: Kruskal Algorithm</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/MST_Kruskal.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find Minimum Spanning Tree (MST) of an Undirected Graph using Kruskal Algorithm - <strong>O(E.log(E)) or O(E.log(V))</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find Minimum Spanning Tree (MST) of an un-/weighted undirected graph </span>
<span class="sd">    based on Prim Algorithm using min-heap</span>
<span class="sd">  Time complexity = O(E.log(V))</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    graph: defaultdict</span>
<span class="sd">           An undirected graph dictionary: { u: {v1: w1, v2: w2} }</span>
<span class="sd">    V    : integer</span>
<span class="sd">           Number of vertex</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    mst    : list</span>
<span class="sd">             An undirected Minimum Spanning Tree list of edges [u, v]</span>
<span class="sd">    minCost: integer</span>
<span class="sd">             Total weights of MST</span>

<span class="sd">  Examples:</span>
<span class="sd">  --------- </span>
<span class="sd">      Undirected graph            Minimum Spanning Tree</span>
<span class="sd">            10                            10</span>
<span class="sd">          0-----1                       0-----1</span>
<span class="sd">          |\    |                        \  </span>
<span class="sd">          | \   |     Prim Algorithm      \       Total weights of MST </span>
<span class="sd">         6|  \5 |15  ================&gt;     \5     = 10 + 5 + 4 = 19</span>
<span class="sd">          |   \ |                           \</span>
<span class="sd">          |    \|                            \</span>
<span class="sd">          2-----3                       2-----3</span>
<span class="sd">             4                             4 </span>

<span class="sd">    &gt;&gt;&gt; graph = {0: {1: 10, 2: 6, 3: 5}, 1: {0: 10, 3: 15}, 2: {0: 6, 3: 4}, 3: {0: 5, 1: 15, 2: 4}}</span>
<span class="sd">    &gt;&gt;&gt; V = 4</span>
<span class="sd">    &gt;&gt;&gt; print(MST_Prim(graph, V))</span>
<span class="sd">    ([[0, 1], [3, 2], [0, 3]], 19)</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span>

<span class="k">def</span><span class="w"> </span><span class="nf">MST_Prim</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>       
  <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="n">V</span> <span class="c1"># Store min-distance from a vertex</span>
  <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Set node 0 as starting node of MST</span>

  <span class="n">minHeap</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)]</span> <span class="c1"># Heap to store distances</span>
  <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Set of already visited nodes</span>
  <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">V</span> <span class="c1"># List to store parents of nodes     </span>
  
  <span class="k">while</span> <span class="n">minHeap</span><span class="p">:</span> 
    <span class="n">_</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span> <span class="c1"># Extract node &quot;u&quot; that haves smallest weight in min-heap</span>
  
    <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">continue</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>  

    <span class="c1"># Run through all adjacent vertices of the extracted vertex u and update their distance values </span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span> 
      <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">continue</span>
      <span class="n">w</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span> 
        <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span> 
        <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span> 
        <span class="c1"># Update distance value in min heap </span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">minHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
  
  <span class="n">mst</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">v</span><span class="p">,</span> <span class="n">u</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="p">]</span> <span class="c1"># The complete MST</span>
  <span class="n">minCost</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="c1"># Total weights of the MST</span>
  <span class="k">return</span> <span class="n">mst</span><span class="p">,</span> <span class="n">minCost</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find Minimum Spanning Tree (MST) of an undirected graph using</span>
<span class="sd">    Kruskal algorithm</span>
<span class="sd">  Time complexity = O(E.log(E)) or O(E.log(V))</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    graph: list</span>
<span class="sd">           An undirected graph list of edges [u,v,w]</span>
<span class="sd">    V    : integer</span>
<span class="sd">           Number of vertex</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    mst    : list</span>
<span class="sd">             An undirected Minimum Spanning Tree list of edges [u,v,w]</span>
<span class="sd">    minCost: integer</span>
<span class="sd">             Total weights of MST</span>

<span class="sd">  Examples:</span>
<span class="sd">  --------- </span>
<span class="sd">      Undirected graph            Minimum Spanning Tree</span>
<span class="sd">            10                            10</span>
<span class="sd">          0-----1                       0-----1</span>
<span class="sd">          |\    |                        \  </span>
<span class="sd">          | \   |    Kruskal Algorithm    \       Total weights of MST </span>
<span class="sd">         6|  \5 |15  ================&gt;     \5     = 10 + 5 + 4 = 19</span>
<span class="sd">          |   \ |                           \</span>
<span class="sd">          |    \|                            \</span>
<span class="sd">          2-----3                       2-----3</span>
<span class="sd">             4                             4 </span>

<span class="sd">    &gt;&gt;&gt; graph = [[0, 1, 10], [0, 2, 6], [0, 3, 5], [1, 3, 15], [2, 3, 4]]</span>
<span class="sd">    &gt;&gt;&gt; print(MST_Kruskal(graph, 4))</span>
<span class="sd">    ([[2, 3, 4], [0, 3, 5], [0, 1, 10]], 19)</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">MST_Kruskal</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">V</span><span class="p">):</span>
  <span class="c1"># Function to create a subset of element nodes</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">DisjointSet_Subset</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">rank</span><span class="p">):</span>
    <span class="n">subset</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;parent&#39;</span><span class="p">:</span> <span class="n">parent</span><span class="p">,</span> <span class="s1">&#39;rank&#39;</span><span class="p">:</span> <span class="n">rank</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">subset</span>

  <span class="c1"># Function to find subset of an element node (uses path compression technique)</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">DisjointSet_Find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">node</span><span class="p">:</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DisjointSet_Find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">subsets</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span>
  
  <span class="c1"># Function that does union of two subsets of u and v (uses union by rank)</span>
  <span class="k">def</span><span class="w"> </span><span class="nf">DisjointSet_Union</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
    <span class="c1"># Attach smaller rank tree under root of high rank tree (Union by Rank)</span>
    <span class="k">if</span> <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]:</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
    <span class="k">elif</span> <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]:</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
    <span class="c1"># If ranks are same, then make one as root and increment its rank by one</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;parent&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
      <span class="n">subsets</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="c1"># Main function</span>
  <span class="n">mst</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># This will store the resultant MST    </span>
  <span class="n">minCost</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Total weights of MST   </span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Index of sorted edges with weights being in ascending order</span>
  <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Number of current edges of MST</span>

  <span class="c1"># Step 1: Sort all the edges in ascending order of their weight</span>
  <span class="n">sorted_graph</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">item</span><span class="p">:</span> <span class="n">item</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

  <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span> 
  <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">V</span><span class="p">):</span>
    <span class="n">subsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DisjointSet_Subset</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
 
  <span class="c1"># MST&#39;s number of edges must be V-1</span>
  <span class="k">while</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">V</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
    <span class="c1"># Step 2: Pick the smallest edge and increase the index for next iteration</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="n">sorted_graph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">DisjointSet_Find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">DisjointSet_Find</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
      
    <span class="c1"># If including this edge doesn&#39;t cause cycle, include it in current MST </span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
      <span class="n">e</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">mst</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">])</span>
      <span class="n">DisjointSet_Union</span><span class="p">(</span><span class="n">subsets</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
      <span class="n">minCost</span> <span class="o">+=</span> <span class="n">w</span>
    <span class="c1"># Else discard the edge</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">pass</span>

  <span class="k">return</span> <span class="n">mst</span><span class="p">,</span> <span class="n">minCost</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="shortest-path">
<h2>Shortest Path<a class="headerlink" href="#shortest-path" title="Link to this heading">#</a></h2>
<div class="pst-scrollable-table-container"><table class="table">
<thead>
<tr class="row-odd"><th class="head text-center"><p>Type of Algorithm</p></th>
<th class="head text-center"><p>Subjects of Application</p></th>
<th class="head text-center"><p>Time Complexity</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-center"><p>Breadth-First Search</p></td>
<td class="text-center"><p>Unweighted, Un-/Directed Graph</p></td>
<td class="text-center"><p>O(V+E) for Adjacency List</p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>Dijkstra</p></td>
<td class="text-center"><p>Non-Negative Un-/Weighted Un-/Directed Graph</p></td>
<td class="text-center"><p>O(E.log(V)) for Min-priority Queue</p></td>
</tr>
<tr class="row-even"><td class="text-center"><p>Bellman-Ford</p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p></p></td>
</tr>
<tr class="row-odd"><td class="text-center"><p>Floyd-Warshall</p></td>
<td class="text-center"><p></p></td>
<td class="text-center"><p></p></td>
</tr>
</tbody>
</table>
</div>
<ol class="arabic simple" start="12">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Searching%20and%20Graph%20Algorithms/SP_BFS.ipynb"><span class="xref myst">Shortest Path: Breadth-First Search</span></a>: Find the Shortest Path in a Unweighted Un-/Directed Graph based on BFS - <strong>O(V+E) for Adjacency List</strong> , V, E is the number of vertices and edges</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Searching%20and%20Graph%20Algorithms/SP_Dijkstra_MinHeap.ipynb"><span class="xref myst">Shortest Path: Dijkstra using Min-Heap</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/SP_Dijkstra_MinHeap.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find Shortest Path of an Non-Negative Un-/Weighted Un-/Directed Graph based on Dijkstra Algorithm using Min-Heap - <strong>O(E.log(V))</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="disabled" type="checkbox"> Shortest Path: Bellman-Ford</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="disabled" type="checkbox"> Shortest Path: Floyd-Warshall</p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find Shortest Path based on BFS</span>
<span class="sd">  Time complexity = O(V+E); V, E is the number of vertices and edges</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    graph: defaultdict</span>
<span class="sd">           Graph, each starting vertex as a key is a list of ending vertices</span>
<span class="sd">    start: integer, string</span>
<span class="sd">           Starting vertex of the shortest path</span>
<span class="sd">    end  : integer, string</span>
<span class="sd">           Ending vertex of the shortest path</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    new_path: list</span>
<span class="sd">              Shortest path, contains all nodes on the path</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; graph = {0: [1, 3], 1: [2], 3: [4, 7], 4: [5, 6, 7], 5: [6], 6: [7]}</span>
<span class="sd">    &gt;&gt;&gt; print(SP_BFS(graph, 0, 7))</span>
<span class="sd">    [0, 3, 7]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">SP_BFS</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span> 
  <span class="n">explored</span> <span class="o">=</span> <span class="p">[]</span> 
      
  <span class="c1"># Queue for traversing the graph in the BFS </span>
  <span class="n">queue</span> <span class="o">=</span> <span class="p">[[</span><span class="n">start</span><span class="p">]]</span> 
      
  <span class="c1"># Loop to traverse the graph with the help of the queue </span>
  <span class="k">while</span> <span class="n">queue</span><span class="p">:</span> 
    <span class="n">path</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> 
    <span class="n">node</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
          
    <span class="c1"># Condition to check if the current node is not visited </span>
    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span><span class="p">:</span> 
      <span class="n">neighbours</span> <span class="o">=</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> 
              
      <span class="c1"># Loop to iterate over the neighbours of the node </span>
      <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">:</span> 
        <span class="n">new_path</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> 
        <span class="n">new_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span> 
        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_path</span><span class="p">)</span> 
                  
        <span class="c1"># Condition to check if the neighbour node is the end </span>
        <span class="k">if</span> <span class="n">neighbour</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span> 
          <span class="k">return</span> <span class="n">new_path</span>

      <span class="n">explored</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find shortest path of an non-negative un-/weighted un-/directed graph</span>
<span class="sd">    based on Dijkstra Algorithm using min-heap</span>
<span class="sd">  Time complexity = E.log(V)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    graph: defaultdict</span>
<span class="sd">           Graph, each starting vertex as a key is a dictionary of ending vertices</span>
<span class="sd">           and weights</span>
<span class="sd">    V    : integer</span>
<span class="sd">           Number of vertices</span>
<span class="sd">    src  : integer</span>
<span class="sd">           Source node of the shortest path</span>
<span class="sd">    end  : integer, optional</span>
<span class="sd">           Ending node of the shortest path (0 by default)</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    path: list</span>
<span class="sd">          Shortest path, contains all nodes on the path</span>
<span class="sd">    dist: list</span>
<span class="sd">          Minimum distance from source to all nodes in the graph</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    Given a weighted undirected graph:</span>
<span class="sd">                 20              24</span>
<span class="sd">         3(end)-------0(source)-------1</span>
<span class="sd">              |      /</span>
<span class="sd">              |     /</span>
<span class="sd">              |    /</span>
<span class="sd">            12|   /3</span>
<span class="sd">              |  /</span>
<span class="sd">              | /</span>
<span class="sd">              |/</span>
<span class="sd">              2</span>
<span class="sd">    Shortest path from 0 to 3 is 0 -&gt; 2 -&gt; 3, having weight = 15</span>

<span class="sd">    &gt;&gt;&gt; graph = {0: {1: 24, 3: 20, 2: 3}, 1: {0: 24}, 3: {0: 20, 2: 12}, 2: {0: 3, 3: 12}}</span>
<span class="sd">    &gt;&gt;&gt; V = 4</span>
<span class="sd">    &gt;&gt;&gt; src = 0</span>
<span class="sd">    &gt;&gt;&gt; end = 3</span>
<span class="sd">    &gt;&gt;&gt; print(SP_Dijkstra_MinHeap(graph, V, src, end))</span>
<span class="sd">    ([0, 2, 3], [0, 24, 3, 15])</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span>

<span class="k">def</span><span class="w"> </span><span class="nf">SP_Dijkstra_MinHeap</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
  <span class="n">dist</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)]</span> <span class="o">*</span> <span class="n">V</span> <span class="c1"># Store min-distance from a vertex</span>
  <span class="n">dist</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="n">minHeap</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="n">src</span><span class="p">)]</span> <span class="c1"># Heap to store distances</span>
  <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Set of already visited nodes</span>
  <span class="n">parent</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">V</span> <span class="c1"># List to store parents of nodes</span>

  <span class="k">while</span> <span class="n">minHeap</span><span class="p">:</span>
    <span class="n">d</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">minHeap</span><span class="p">)</span> <span class="c1"># Extract min distance &quot;d&quot; and its node &quot;u&quot; in min-heap</span>

    <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">continue</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>    
              
    <span class="c1"># Run through all adjacent vertices of the extracted vertex u and update their distance values </span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
      <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span> <span class="k">continue</span>
      <span class="n">new_d</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">new_d</span>  <span class="o">&lt;</span> <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_d</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
        <span class="c1"># Update distance value in min heap </span>
        <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">minHeap</span><span class="p">,</span> <span class="p">(</span><span class="n">new_d</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

  <span class="c1"># Find shortest path from source to end vertex        </span>
  <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">end</span><span class="p">]</span>
  <span class="n">v</span> <span class="o">=</span> <span class="n">end</span>
  <span class="k">while</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">src</span><span class="p">:</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
    <span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">u</span>

  <span class="k">return</span> <span class="n">path</span><span class="p">,</span> <span class="n">dist</span>

<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span> <span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">24</span><span class="p">},</span> <span class="mi">3</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mi">12</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">12</span><span class="p">}}</span>
<span class="n">V</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">src</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">end</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nb">print</span><span class="p">(</span><span class="n">SP_Dijkstra_MinHeap</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
</section>
</section>
<section id="d-greedy-algorithm">
<h1>D) Greedy Algorithm<a class="headerlink" href="#d-greedy-algorithm" title="Link to this heading">#</a></h1>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#../22SPAR-coding-all/Greedy%20Algorithm/Sherlock_and_The_Beast.ipynb"><span class="xref myst">Sherlock and The Beast</span></a></p></li>
</ol>
<ul class="simple">
<li><p>Find the “Decent Number” having n Digits (“Decent Number” has its digits to be only 3’s and/or 5’s; the number of 3’s it contains is divisible by 5; the number of 5’s it contains is divisible by 3; and it is the largest such number for its length)</p></li>
</ul>
<ol class="arabic simple" start="2">
<li><p><a class="reference internal" href="#../22SPAR-coding-all/Greedy%20Algorithm/Largest_Permutation.ipynb"><span class="xref myst">Largest Permutation</span></a></p></li>
</ol>
<ul class="simple">
<li><p>Swap 2 digits of a number k times to get largest number - <strong>O(n)</strong></p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">decentNumber</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="k">5</span> == 0 and n%3 == 0:
      <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;5&#39;</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>

  <span class="k">elif</span> <span class="n">n</span><span class="o">%</span><span class="k">3</span> == 0:
      <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;5&#39;</span><span class="o">*</span><span class="n">n</span><span class="p">)</span>
  
  <span class="c1"># If no match above, then n-digit-result is composed by</span>
  <span class="c1"># (3*b) digits of 5 and (5*a) digits of 3</span>
  <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="o">//</span><span class="mi">5</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">%</span><span class="k">3</span> == 0:
        <span class="n">b</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">n</span> <span class="o">-</span> <span class="mi">5</span><span class="o">*</span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="s1">&#39;5&#39;</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;3&#39;</span><span class="o">*</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">a</span><span class="p">))</span>
    
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
  <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>

  <span class="k">for</span> <span class="n">t_itr</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">decentNumber</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">NOTE:</span>
<span class="sd">- Time complexity = O(n)</span>
<span class="sd">- The trick is to use dictionary to store {value:index} of the array, </span>
<span class="sd">so we can access index faster</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="c1"># Complete the largestPermutation function below.</span>
<span class="k">def</span><span class="w"> </span><span class="nf">largestPermutation</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">arr</span><span class="p">):</span>
  <span class="c1"># Create a dictionary to store values and indices of arr</span>
  <span class="c1"># This will reduce much time to take index of a value</span>
  <span class="c1"># {value1:index1, value2:index2, ..., valueN:indexN}</span>
  <span class="nb">dict</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
    <span class="nb">dict</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">i</span>

  <span class="c1"># Check each value in arr to see if we can swap</span>
  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
    <span class="c1"># Extract index of max value in arr[j:len(arr)]</span>
    <span class="c1"># Max value = len(arr)-j </span>
    <span class="c1"># Time = O(1) instead of O(n) by using max(arr[j:len(arr)])</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="n">j</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">idx</span><span class="p">:</span>
      <span class="c1"># Update new indices of 2 swapped values</span>
      <span class="nb">dict</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">j</span>
      <span class="nb">dict</span><span class="p">[</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">idx</span>
      <span class="c1"># Swap 2 values</span>
      <span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span><span class="n">arr</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
      <span class="c1"># Lose 1 swap after that</span>
      <span class="n">k</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># If there&#39;s no swap allowed anymore</span>
    <span class="k">elif</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">break</span>

  <span class="k">return</span> <span class="n">arr</span>
  
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
  <span class="n">nk</span> <span class="o">=</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
  <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">nk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

  <span class="n">arr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>

  <span class="n">result</span> <span class="o">=</span> <span class="n">largestPermutation</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">result</span><span class="p">)))</span>
  
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
</section>
<section id="e-dynamic-programming">
<h1>E) Dynamic Programming<a class="headerlink" href="#e-dynamic-programming" title="Link to this heading">#</a></h1>
<blockquote>
<div><p><strong>Coin Change Algorithms</strong>: Given an array of choices, every choice is picked <strong>unlimited times</strong></p>
<p><strong>Knapsack Problems</strong>: Given an array of choices, every choice is picked <strong>only once</strong></p>
</div></blockquote>
<section id="coin-change-algorithms">
<h2>Coin Change Algorithms<a class="headerlink" href="#coin-change-algorithms" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/CoinChange.ipynb"><span class="xref myst">Coin Change</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/Coin%20Change.pdf"><span class="xref myst">[PDF]</span></a></sup>: How many ways to pay V money using C coins [C1,C2,…Cn] - <strong>O(C.V)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/IntegerPartition.ipynb"><span class="xref myst">Integer Partition</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/Integer_Partition.pdf"><span class="xref myst">[PDF]</span></a></sup>: How many ways to partition number N using [1,2,…N] numbers - <strong>O(n<sup>1.5</sup>)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/MinCoinChange.ipynb"><span class="xref myst">Minimum Coin Change</span></a><sup><a class="reference external" href="https://en.wikipedia.org/wiki/Change-making_problem">[Wiki]</a></sup>: Find Minimum Number of Coins to pay V money using C coins [C1,C2,…,Cn] - <strong>O(C.V)</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find how many ways to pay V money using C coins [C1,C2,...,Cn]</span>
<span class="sd">  Time complexity = O(C.V)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    V     : integer</span>
<span class="sd">            Value of money to be paid</span>
<span class="sd">    C     : list</span>
<span class="sd">            All coin types available </span>
<span class="sd">    output: &#39;single&#39; (by default) or &#39;all&#39;, optional</span>
<span class="sd">            2 types of output</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    output = &#39;single&#39;: integer</span>
<span class="sd">                       Number of ways to pay V using C coins</span>
<span class="sd">    output = &#39;all&#39;   : list</span>
<span class="sd">                       All numbers of ways to pay each [1,2,...,V] money using C coins</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">      With 4 types of coins C = [8,3,1,2], we can make change for V = 3 in</span>
<span class="sd">      3 ways: {1,1,1}, {1,2} and {3}</span>

<span class="sd">    &gt;&gt;&gt; C = [8,3,1,2]</span>
<span class="sd">    &gt;&gt;&gt; V = 3</span>
<span class="sd">    &gt;&gt;&gt; print(CoinChange(V, C))</span>
<span class="sd">    3</span>

<span class="sd">      To pay 1 money, we have 1 way : {1}</span>
<span class="sd">             2 money, we have 2 ways: {1,1} and {2}</span>
<span class="sd">             3 money, we have 3 ways: {1,1,1}, {1,2} and {3}</span>
<span class="sd">             </span>
<span class="sd">    &gt;&gt;&gt; C = [8,3,1,2]</span>
<span class="sd">    &gt;&gt;&gt; V = 3</span>
<span class="sd">    &gt;&gt;&gt; print(CoinChange(V, C, output=&#39;all&#39;))</span>
<span class="sd">    [1, 1, 2, 3]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">CoinChange</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">):</span>
  <span class="n">memo</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">V</span> <span class="c1"># Memory for dynamic programming</span>
  
  <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coin</span><span class="p">,</span><span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
      <span class="n">memo</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">+=</span> <span class="n">memo</span><span class="p">[</span><span class="n">val</span><span class="o">-</span><span class="n">coin</span><span class="p">]</span>
  
  <span class="c1"># 2 ways of output: &#39;single&#39; or &#39;all&#39;</span>
  <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="n">memo</span>
  <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="n">memo</span><span class="p">[</span><span class="n">V</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find how many ways to partition number N using [1,2,...N] numbers</span>
<span class="sd">  Time complexity = O(n^1.5) </span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    N     : integer</span>
<span class="sd">            Input number to be partitioned</span>
<span class="sd">    output: &#39;single&#39; (by default) or &#39;all&#39;, optional</span>
<span class="sd">            2 types of output</span>
<span class="sd">            </span>
<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    output = &#39;single&#39;: integer </span>
<span class="sd">                       Number of ways to partition number N (by default)</span>
<span class="sd">    output = &#39;all&#39;   : list</span>
<span class="sd">                       All numbers of ways to partition all numbers from 0 to N</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    With 5 types of coins [1, 2, 3, 4, 5], we can make change for N = 5 in 7 ways:</span>
<span class="sd">          5 = 5</span>
<span class="sd">            = 4+1</span>
<span class="sd">            = 3+2</span>
<span class="sd">            = 3+1+1</span>
<span class="sd">            = 2+2+1</span>
<span class="sd">            = 2+1+1+1</span>
<span class="sd">            = 1+1+1+1+1</span>

<span class="sd">    &gt;&gt;&gt; N = 5</span>
<span class="sd">    &gt;&gt;&gt; ways = IntegerPartition(N,output=&#39;single&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(ways)</span>
<span class="sd">    7</span>

<span class="sd">    &gt;&gt;&gt; N = 5</span>
<span class="sd">    &gt;&gt;&gt; ways = IntegerPartition(N,output=&#39;all&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(ways)</span>
<span class="sd">    [1, 1, 2, 3, 5, 7]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">sqrt</span>

<span class="k">def</span><span class="w"> </span><span class="nf">IntegerPartition</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;single&#39;</span><span class="p">):</span>
  <span class="c1"># List of generalized pentagonal numbers for generating function</span>
  <span class="n">k</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([[</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">250</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">N</span><span class="p">))))],</span> <span class="p">[])</span>
  
  <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># List to count how many ways to partition number n</span>
  <span class="n">sgn</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># List of signs</span>
  <span class="n">n</span>  <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Starting number</span>

  <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>    <span class="c1"># Expand generating function to calculate p(n)</span>
    <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">px</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">px</span> <span class="o">+=</span> <span class="n">p</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">*</span> <span class="n">sgn</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="k">4</span>]
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">p</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">px</span><span class="p">)</span>
  
  <span class="c1"># 2 types of output: &#39;all&#39; or &#39;single&#39;</span>
  <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="n">p</span>
  <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;single&#39;</span><span class="p">:</span> <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="c1"># By default</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find minimum number of coins to pay V money using C coins [C1,C2,...,Cn]</span>
<span class="sd">  Time complexity = O(C.V)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    V     : integer</span>
<span class="sd">            Value of money to be paid</span>
<span class="sd">    C     : list</span>
<span class="sd">            All coin types available </span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    Integer: If it&#39;s possible to pay V using C coins</span>
<span class="sd">    Inf    : if it&#39;s impossible to pay V using C coins</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">      With 3 types of coins C = [5,1,3], we can make change for V = 11 using </span>
<span class="sd">      at least 3 coins: {5}, {5} and {1}</span>

<span class="sd">    &gt;&gt;&gt; V = 11</span>
<span class="sd">    &gt;&gt;&gt; C = [5,1,3]</span>
<span class="sd">    &gt;&gt;&gt; print(MinCoinChange(V, C))</span>
<span class="sd">    3</span>

<span class="sd">      With 3 types of coins C = [5,3,6], there&#39;s no way to make change for V = 11</span>

<span class="sd">    &gt;&gt;&gt; V = 2</span>
<span class="sd">    &gt;&gt;&gt; C = [5,3,6]</span>
<span class="sd">    &gt;&gt;&gt; print(MinCoinChange(V, C))</span>
<span class="sd">    inf</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">MinCoinChange</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
  <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)]</span><span class="o">*</span><span class="n">V</span> <span class="c1"># Memory for dynamic programming</span>
        
  <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">coin</span><span class="p">,</span> <span class="n">V</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
      <span class="n">dp</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">val</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">val</span><span class="o">-</span><span class="n">coin</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
     
  <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="n">V</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="knapsack-problems">
<h2>Knapsack Problems<a class="headerlink" href="#knapsack-problems" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="4">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/Knapsack_01.ipynb"><span class="xref myst">Knapsack 0/1</span></a><sup><a class="reference external" href="https://en.wikipedia.org/wiki/Knapsack_problem#0-1_knapsack_problem">[Wiki]</a></sup>: Given a List of Weights associated with their Values, find the Founding Weights and Maximum Total Value attained with its Total Weight &lt;= Given Total Weight, each Weight is only <strong>picked once</strong> (0/1 Rule)  - <strong>O(N.W)</strong> , N, W is length of weights array and given total weight</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/PartitionProblem_SubsetSum.ipynb"><span class="xref myst">Partition Problem: Subset Sum</span></a><sup><a class="reference external" href="https://en.wikipedia.org/wiki/Subset_sum_problem">[Wiki]</a></sup>: Given an Array containing only Positive Integers, find if it can be Partitioned into 2 Subsets having Sum of elements in both subsets is Equal.  - <strong>O(N.T)</strong> , N, T is the length of numbers array and the target sum (=sum/2)</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" disabled="disabled" type="checkbox"> Partition Problem: Multiway Number Partitioning<sup><a class="reference external" href="https://en.wikipedia.org/wiki/Multiway_number_partitioning">[Wiki]</a></sup>:</p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Given a List of Weights associated with their Values, find the Founding Weights and</span>
<span class="sd">  Maximum Total Value attained with its Total Weight &lt;= Given Total Weight, </span>
<span class="sd">  each Weight is only picked once (0/1 Rule) </span>

<span class="sd">  Time complexity = O(|weights|*totalWeight) </span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    totalWeight: int</span>
<span class="sd">                 Total weight that can be reached</span>
<span class="sd">    weights    : list</span>
<span class="sd">                 List of weights in ascending order</span>
<span class="sd">    values     : list</span>
<span class="sd">                 List of values associated with weights</span>
<span class="sd">    output     : &#39;MaxTotalValue&#39; (by default) or &#39;Weights&#39;, optional</span>
<span class="sd">                 2 types of output: Maximum Total Value or Founding Weights</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    Maximum total value: int</span>
<span class="sd">    subset             : list</span>
<span class="sd">                         List of Founding Weights</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    Given an weights array [1, 3, 4, 5] with its values array [1, 4, 5, 7]. </span>
<span class="sd">    The maximum total value is 9, which can be attained by the weight 3 and 4.</span>

<span class="sd">    The dynamic programming matrix looks like this:</span>
<span class="sd">      [[0, 1, 1, 1, 1, 1, 1, 1], </span>
<span class="sd">       [0, 1, 1, 4, 5, 5, 5, 5], </span>
<span class="sd">       [0, 1, 1, 4, 5, 6, 6, 9], </span>
<span class="sd">       [0, 1, 1, 4, 5, 7, 8, 9]]</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; totalWeight = 7</span>
<span class="sd">    &gt;&gt;&gt; weights = [1, 3, 4, 5]</span>
<span class="sd">    &gt;&gt;&gt; values = [1, 4, 5, 7]</span>
<span class="sd">    &gt;&gt;&gt; print(Knapsack_01(totalWeight, weights, values))</span>
<span class="sd">    9</span>

<span class="sd">    To find what weights constitute the maximum total value 9, the algorithm </span>
<span class="sd">    follows the path coordinate like this: (3,7) -&gt; (2,7) -&gt; (1,3) -&gt; (0,0).</span>

<span class="sd">    &gt;&gt;&gt; print(Knapsack_01(totalWeight, weights, values, output=&#39;Weights&#39;))</span>
<span class="sd">    [4, 3]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Knapsack_01</span><span class="p">(</span><span class="n">totalWeight</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">output</span> <span class="o">=</span> <span class="s1">&#39;MaxTotalValue&#39;</span><span class="p">):</span>
  <span class="c1"># Warning: Weights must be sorted in ascending order</span>

  <span class="n">R</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">),</span> <span class="n">totalWeight</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span>

  <span class="n">count</span> <span class="o">=</span> <span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Cumulative weight</span>
  <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">):</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

  <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="n">weights</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">weights</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
      <span class="k">elif</span> <span class="n">weights</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">:</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">],</span> <span class="n">values</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span> <span class="o">-</span> <span class="n">weights</span><span class="p">[</span><span class="n">r</span><span class="p">]])</span>
      <span class="k">elif</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">:</span> 
        <span class="c1"># Every weight is only picked once, so there&#39;s no more value gained</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

  <span class="c1"># There are 2 types of output: &#39;MaxTotalValue&#39; (by default) or &#39;Weights&#39;</span>
  <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;MaxTotalValue&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

  <span class="c1"># Algorithm to find weights that founded the Maximum Total Value</span>
  <span class="k">elif</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;Weights&#39;</span><span class="p">:</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="n">R</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">C</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">subset</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">subset</span>
      
      <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
          <span class="n">r</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
          <span class="n">c</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
          <span class="n">c</span> <span class="o">-=</span> <span class="n">weights</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
          <span class="n">r</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">continue</span>

      <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]:</span>
          <span class="n">c</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">subset</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">weights</span><span class="p">[</span><span class="n">r</span><span class="p">])</span>
          <span class="n">c</span> <span class="o">-=</span> <span class="n">weights</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
        <span class="k">continue</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Given an array containing only positive integers, find if it can be partitioned </span>
<span class="sd">  into two subsets having sum of elements in both subsets is equal. </span>

<span class="sd">  Time complexity = O(N.T), N, T is length of numbers array and target sum (=sum/2) </span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    nums: list</span>
<span class="sd">          List of numbers</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    True/False</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    1) Given an array [1, 2, 3, 4], this can be partitioned into 2 subsets having</span>
<span class="sd">    equal sum = 5: [1, 4] and [2, 3]. So the target sum is 5.</span>

<span class="sd">      The dynamic programming matrix looks like this:</span>
<span class="sd">      [[0, 1, 1, 1, 1, 1], </span>
<span class="sd">       [0, 1, 2, 3, 3, 3], </span>
<span class="sd">       [0, 1, 2, 3, 4, 5], </span>
<span class="sd">       [0, 0, 0, 0, 0, 0]]</span>

<span class="sd">    &gt;&gt;&gt; nums = [1, 2, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; print(PartitionProblem_SubsetSum(nums))</span>
<span class="sd">    True</span>

<span class="sd">    2) Given an array [2,2,3,5], this can&#39;t be partitioned into 2 subsets having</span>
<span class="sd">    equal sum. So the target sum is (2+2+3+5)/2 = 6.</span>

<span class="sd">      The dynamic programming matrix looks like this:</span>
<span class="sd">      [[0, 0, 2, 2, 2, 2, 2], </span>
<span class="sd">       [0, 0, 2, 2, 4, 4, 4], </span>
<span class="sd">       [0, 0, 2, 3, 4, 5, 5], </span>
<span class="sd">       [0, 0, 2, 3, 4, 5, 5]]</span>

<span class="sd">    &gt;&gt;&gt; nums = [2,2,3,5]</span>
<span class="sd">    &gt;&gt;&gt; print(PartitionProblem_SubsetSum(nums))</span>
<span class="sd">    False</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">PartitionProblem_SubsetSum</span><span class="p">(</span><span class="n">nums</span><span class="p">):</span>
  <span class="n">nums</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="c1"># Number list must be sorted in ascending order</span>
    
  <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">tg</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span> <span class="c1"># Target sum</span>
      
  <span class="c1"># Modified Knapsack 0/1 Algorithm</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">tg</span><span class="p">:</span>
      <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="k">break</span>
  <span class="n">R</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tg</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Number of rows and columns for DP matrix</span>
    
  <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span> <span class="c1"># DP matrix</span>
    
  <span class="n">count</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Cumulative sum</span>
  <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">):</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
  <span class="c1"># Original Knapsack 0/1 Algorithm</span>
  <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>
    <span class="n">count</span> <span class="o">+=</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]</span>
      <span class="k">elif</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">count</span><span class="p">:</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="o">-</span><span class="n">nums</span><span class="p">[</span><span class="n">r</span><span class="p">]])</span>
      <span class="k">elif</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="n">count</span><span class="p">:</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
      
    <span class="c1"># Modified part to check if numbers can found target sum</span>
    <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">tg</span><span class="p">:</span>
      <span class="k">return</span> <span class="kc">True</span>
   
  <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="path-sum-problems">
<h2>Path Sum Problems<a class="headerlink" href="#path-sum-problems" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="7">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/Max_PathSum_Triangle.ipynb"><span class="xref myst">Max Path Sum Triangle</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/Max_PathSum_Triangle.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find Maximum Path Sum from Top to Bottom of a Triangle - <strong>O(R)</strong> , R is number of rows of the triangle</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/Min_PathSum_Matrix.ipynb"><span class="xref myst">Min Path Sum Matrix: Top-Left to Right-Bottom, Right and Down Moves</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/Min_PathSum_Matrix.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find Min Path Sum from Top-Left to Right-Bottom of a Matrix using Right and Down Moves - <strong>O(R.C)</strong> , R, C is length of row and column of the matrix</p></li>
</ul>
</li>
</ol>
<blockquote>
<div><p><strong>Subsequence</strong> = Any subset of an array/string</p>
<p><strong>Subarray</strong> = Contiguous subsequence of an array</p>
<p><strong>Substring</strong> = Contiguous subsequence of a string</p>
</div></blockquote>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find Maximum Path Sum from top to bottom of a Triangle</span>
<span class="sd">  Time complexity = O(R), R is number of rows of the triangle</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    tri: list</span>
<span class="sd">         Input triangle</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    maxSum: integer</span>
<span class="sd">            Max sum of the path from top to bottom</span>

<span class="sd">  Examples:</span>
<span class="sd">  --------- </span>
<span class="sd">         3                                        [3]</span>
<span class="sd">        7 5             Max sum path            [7]  5    </span>
<span class="sd">       2 4 6    ===========================&gt;    2 [4] 6     </span>
<span class="sd">      8 5 9 3   Max sum = 3 + 7 + 4 + 9 = 23   8 5  [9] 3</span>

<span class="sd">          8                                           [8]</span>
<span class="sd">       -4   4             Max sum path              -4   [4]    </span>
<span class="sd">      2   2   6    ===========================&gt;    2   2   [6]     </span>
<span class="sd">     1  1   1  1   Max sum = 8 + 4 + 6 + 1 = 19   1  1   [1]  1</span>

<span class="sd">    &gt;&gt;&gt; tri = [[3],</span>
<span class="sd">               [7,4],</span>
<span class="sd">               [2,4,6],</span>
<span class="sd">               [8,5,9,3]]</span>
<span class="sd">    &gt;&gt;&gt; print(Max_PathSum_Triangle(tri))</span>
<span class="sd">    23</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">copy</span><span class="w"> </span><span class="kn">import</span> <span class="n">deepcopy</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Max_PathSum_Triangle</span><span class="p">(</span><span class="n">tri</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This algorithm is to find max path sum.</span>
<span class="sd">    For other cases, please modify codes.</span>
<span class="sd">  &#39;&#39;&#39;</span>
  <span class="n">memo</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">tri</span><span class="p">)</span>

  <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">memo</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">memo</span><span class="p">[</span><span class="n">r</span><span class="p">])):</span>
      <span class="n">memo</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">max</span><span class="p">(</span><span class="n">memo</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">],</span><span class="n">memo</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
  
  <span class="n">maxSum</span> <span class="o">=</span> <span class="n">memo</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Top of the triangle is the accumulative sum</span>
  <span class="k">return</span> <span class="n">maxSum</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find min path sum from top-left to right-bottom element of a matrix</span>
<span class="sd">  Time complexity = O(R.C); R, C is length of row and column of the matrix</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    m: list</span>
<span class="sd">       Input matrix</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    minCost: integer</span>
<span class="sd">             Min cost value</span>

<span class="sd">  Examples:</span>
<span class="sd">  --------- </span>
<span class="sd">    For a given matrix: </span>
<span class="sd">                        131  673  234  103  18</span>
<span class="sd">                        201  96   342  965  150</span>
<span class="sd">                        630  803  746  422  111</span>
<span class="sd">                        537  699  497  121  956</span>
<span class="sd">                        805  732  524  37   331</span>
<span class="sd">    Top-Left is 131 and Right-Bottom is 331.</span>

<span class="sd">    The minimum sum path is: </span>
<span class="sd">                      [131] 673  234   103   18</span>
<span class="sd">                      [201] [96] [342] 965   150</span>
<span class="sd">                      630   803  [746] [422] 111</span>
<span class="sd">                      537   699  497   [121] 956</span>
<span class="sd">                      805   732  524   [37]  [331]</span>
<span class="sd">    -&gt; 131, 201, 96, 342, 746, 422, 121, 37, 331</span>

<span class="sd">    &gt;&gt;&gt; m = [[131, 673, 234, 103, 18],</span>
<span class="sd">             [201, 96, 342, 965, 150],</span>
<span class="sd">             [630, 803, 746, 422, 111],</span>
<span class="sd">             [537, 699, 497, 121, 956],</span>
<span class="sd">             [805, 732, 524, 37, 331]]</span>
<span class="sd">    &gt;&gt;&gt; print(Min_PathSum_Matrix(m))</span>
<span class="sd">    2427</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Min_PathSum_Matrix</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
<span class="w">  </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This algorithm finds MIN VALUE of sum path from TOP-LEFT to RIGHT-BOTTOM using</span>
<span class="sd">      DOWN and RIGHT moves.</span>
<span class="sd">    For further cases, please modify codes.</span>
<span class="sd">  &#39;&#39;&#39;</span>
  <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">c</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">)]</span>
  
  <span class="c1"># Same value at starting point</span>
  <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
  <span class="c1"># Initialize first column of dp matrix</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
  <span class="c1"># Initialize first row of dp matrix</span>
  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
    <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
  <span class="c1"># Construct rest of the dp matrix</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
      <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
  
  <span class="n">minCost</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
  <span class="k">return</span> <span class="n">minCost</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="subarray-problems">
<h2>Subarray Problems<a class="headerlink" href="#subarray-problems" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="9">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/Max_SubarraySum.ipynb"><span class="xref myst">Max Subarray Sum (Kadane Algorithm)</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/Max_SubarraySum.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find Maximum Subarray Sum of an Array - <strong>O(n)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/Max_SubarraySum_Extended.ipynb"><span class="xref myst">Max Subarray Sum (Kadane Algorithm - Extended)</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/Max_SubarraySum.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find Maximum Subarray Sum of an Array and its Indices - <strong>O(n)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/Min_SubarraySum.ipynb"><span class="xref myst">Min Subarray Sum (Kadane Algorithm’s Min Varient)</span></a>: Find Minimum Subarray Sum of an Array - <strong>O(n)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/SubarraySum_EqualsK.ipynb"><span class="xref myst">Subarray Sum Equals K</span></a><sup><a class="reference external" href="https://leetcode.com/problems/subarray-sum-equals-k/">[Leetcode]</a></sup>: Find the Number of Continuous Subarrays of an Array whose Sum Equals to K - <strong>O(n)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/SubarraySum_DivByK.ipynb"><span class="xref myst">Subarray Sum Divisible by K</span></a><sup><a class="reference external" href="https://leetcode.com/problems/subarray-sums-divisible-by-k/">[Leetcode]</a></sup>: Find the Number of Continuous Subarrays of an Array whose Sum is Divisible by K - <strong>O(n)</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find maximum subarray sum of an array</span>
<span class="sd">  Time complexity = O(n)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    arr: list</span>
<span class="sd">         Input array of numbers</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    best: int</span>
<span class="sd">          Maximum subarray sum</span>

<span class="sd">  Examples:</span>
<span class="sd">  --------- </span>
<span class="sd">      Given an array: [-1, 2, 3, -4, 5, 10]</span>
<span class="sd">      The maximum subarray sum is 16.</span>
<span class="sd">      Its position is 1 and 5.</span>

<span class="sd">    &gt;&gt;&gt; arr = [-1, 2, 3, -4, 5, 10]</span>
<span class="sd">    &gt;&gt;&gt; print(Max_SubarraySum(arr))</span>
<span class="sd">    16</span>

<span class="sd">    &gt;&gt;&gt; arr = [-1, -2, -3, -4, -5, -10]</span>
<span class="sd">    &gt;&gt;&gt; print(Max_SubarraySum(arr))</span>
<span class="sd">    -1</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Max_SubarraySum</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
  <span class="n">curr</span> <span class="o">=</span> <span class="n">best</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Current and max subarray sum</span>
    
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
    <span class="c1"># After adding i, if current subarray sum &gt;= previous subarray sum, </span>
    <span class="c1"># then new subarray starts at i</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">curr</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> 
    <span class="c1"># Memoize max subarray sum</span>
    <span class="n">best</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">best</span><span class="p">,</span> <span class="n">curr</span><span class="p">)</span>
      
  <span class="k">return</span> <span class="n">best</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find maximum subarray sum of an array and its indices</span>
<span class="sd">  Time complexity = O(n)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    arr: list</span>
<span class="sd">         Input array of numbers</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    result: tuple</span>
<span class="sd">            A tuple of maximum subarray sum and its position</span>

<span class="sd">  Examples:</span>
<span class="sd">  --------- </span>
<span class="sd">      Given an array: [-1, 2, 3, -4, 5, 10]</span>
<span class="sd">      The maximum subarray sum is 16.</span>
<span class="sd">      Its position is 1 and 5.</span>

<span class="sd">    &gt;&gt;&gt; arr = [-1, 2, 3, -4, 5, 10]</span>
<span class="sd">    &gt;&gt;&gt; print(Max_SubarraySum_Extended(arr))</span>
<span class="sd">    (16, 1, 5)</span>

<span class="sd">    &gt;&gt;&gt; arr = [-1, -2, -3, -4, -5, -10]</span>
<span class="sd">    &gt;&gt;&gt; print(Max_SubarraySum_Extended(arr))</span>
<span class="sd">    (-1, 0, 0)</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Max_SubarraySum_Extended</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
  <span class="n">best_sum</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># or: float(&#39;-inf&#39;)</span>
  <span class="n">best_start</span> <span class="o">=</span> <span class="n">best_end</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># or: None</span>
  <span class="n">current_sum</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">for</span> <span class="n">current_end</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">current_sum</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># Start a new sequence at the current element</span>
      <span class="n">current_start</span> <span class="o">=</span> <span class="n">current_end</span>
      <span class="n">current_sum</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># Extend the existing sequence with the current element</span>
      <span class="n">current_sum</span> <span class="o">+=</span> <span class="n">x</span>

    <span class="k">if</span> <span class="n">current_sum</span> <span class="o">&gt;</span> <span class="n">best_sum</span><span class="p">:</span>
      <span class="n">best_sum</span> <span class="o">=</span> <span class="n">current_sum</span>
      <span class="n">best_start</span> <span class="o">=</span> <span class="n">current_start</span>
      <span class="n">best_end</span> <span class="o">=</span> <span class="n">current_end</span> 

  <span class="k">if</span> <span class="p">(</span><span class="n">best_sum</span><span class="p">,</span> <span class="n">best_start</span><span class="p">,</span> <span class="n">best_end</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">best_sum</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">best_start</span> <span class="o">=</span> <span class="n">best_end</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">best_sum</span><span class="p">)</span>

  <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_sum</span><span class="p">,</span> <span class="n">best_start</span><span class="p">,</span> <span class="n">best_end</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find minimum subarray sum of an array</span>
<span class="sd">  Time complexity = O(n)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    arr: list</span>
<span class="sd">         Input array of numbers</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    result: tuple</span>
<span class="sd">            A tuple of minimum subarray sum and its position</span>

<span class="sd">  Examples:</span>
<span class="sd">  --------- </span>
<span class="sd">      Given an array: [3, -4, 2, -3, -1, 7, -5]</span>
<span class="sd">      The minimum subarray sum is -6.</span>
<span class="sd">      Its position is 1 and 4.</span>

<span class="sd">    &gt;&gt;&gt; arr = [3, -4, 2, -3, -1, 7, -5]</span>
<span class="sd">    &gt;&gt;&gt; print(Min_SubarraySum(arr))</span>
<span class="sd">    (-6, 1, 4)</span>

<span class="sd">    &gt;&gt;&gt; arr = [2, 6, 8, 1, 4]</span>
<span class="sd">    &gt;&gt;&gt; print(Min_SubarraySum(arr))</span>
<span class="sd">    (1, 3, 3)</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Min_SubarraySum</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
  <span class="n">best_sum</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># or: float(&#39;-inf&#39;)</span>
  <span class="n">best_start</span> <span class="o">=</span> <span class="n">best_end</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># or: None</span>
  <span class="n">current_sum</span> <span class="o">=</span> <span class="mi">0</span>

  <span class="k">for</span> <span class="n">current_end</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">current_sum</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
      <span class="c1"># Start a new sequence at the current element</span>
      <span class="n">current_start</span> <span class="o">=</span> <span class="n">current_end</span>
      <span class="n">current_sum</span> <span class="o">=</span> <span class="n">x</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># Extend the existing sequence with the current element</span>
      <span class="n">current_sum</span> <span class="o">+=</span> <span class="n">x</span>

    <span class="k">if</span> <span class="n">current_sum</span> <span class="o">&lt;</span> <span class="n">best_sum</span><span class="p">:</span>
      <span class="n">best_sum</span> <span class="o">=</span> <span class="n">current_sum</span>
      <span class="n">best_start</span> <span class="o">=</span> <span class="n">current_start</span>
      <span class="n">best_end</span> <span class="o">=</span> <span class="n">current_end</span> 

  <span class="k">if</span> <span class="p">(</span><span class="n">best_sum</span><span class="p">,</span> <span class="n">best_start</span><span class="p">,</span> <span class="n">best_end</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
    <span class="n">best_sum</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">best_start</span> <span class="o">=</span> <span class="n">best_end</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">best_sum</span><span class="p">)</span>

  <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">best_sum</span><span class="p">,</span> <span class="n">best_start</span><span class="p">,</span> <span class="n">best_end</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find the number of continuous subarrays of an array whose sum equals to k. </span>
<span class="sd">  Time complexity = O(n) </span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    nums: list</span>
<span class="sd">          The input array</span>
<span class="sd">    k   : int</span>
<span class="sd">          Given sum of subarrays</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    count: int</span>
<span class="sd">           The number of subarrays</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    Given an array [3,4,7,2,-3,1,7] with given sum k = 7. </span>
<span class="sd">    Subarrays that have sum = 7 are:</span>
<span class="sd">    [3,4], [7], [7,2,-3,1], [2,-3,1,7], [7].</span>

<span class="sd">    How the algorithm works?</span>

<span class="sd">    The array of cumulative sum is [0,3,7,14,16,13,14,21].</span>
<span class="sd">    In the algorithm, turn the array into dictionary of cumulative sum and its frequency:</span>
<span class="sd">      memo = {0: 1, 3: 1, 7: 1, 14: 2, 16: 1, 13: 1, 21: 1}</span>

<span class="sd">    For every cumulative sum (called current sum), if (current sum - k) is in memo, </span>
<span class="sd">    then we found subarray(s) having sum = k from index of the sum = current sum - k </span>
<span class="sd">    to index of the current sum.   </span>
<span class="sd">    The number of subarray(s) found is the frequency of the sum = current sum - k.</span>

<span class="sd">    i = 3  -&gt; currSum = 3  -&gt; currSum - k = -4 not in memo -&gt; ignore</span>
<span class="sd">    i = 4  -&gt; currSum = 7  -&gt; currSum - k = 0 in memo      -&gt; count = 1, found [3,4]</span>
<span class="sd">    i = 7  -&gt; currSum = 14 -&gt; currSum - k = 7 in memo      -&gt; count = 2, found [7]</span>
<span class="sd">    i = 2  -&gt; currSum = 16 -&gt; currSum - k = 9 not in memo  -&gt; ignore</span>
<span class="sd">    i = -3 -&gt; currSum = 13 -&gt; currSum - k = 6 not in memo  -&gt; ignore</span>
<span class="sd">    i = 1  -&gt; currSum = 14 -&gt; currSum - k = 7 in memo      -&gt; count = 3, found [7,2,-3,1]</span>
<span class="sd">    i = 7  -&gt; currSum = 21 -&gt; currSum - k = 14 in memo     -&gt; count = 5, found [2,-3,1,7], [7].</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; nums = [3,4,7,2,-3,1,7]</span>
<span class="sd">    &gt;&gt;&gt; k = 7</span>
<span class="sd">    &gt;&gt;&gt; print(SubarraySum_EqualsK(nums, k))</span>
<span class="sd">    5</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">SubarraySum_EqualsK</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
  <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
    
  <span class="n">memo</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># Memoization as: Cumulative sum -&gt; Frequency</span>
  <span class="n">memo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
  <span class="n">currSum</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Current cumulative sum</span>
  <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Number of continuous subarrays whose sum = k</span>
    
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
    <span class="n">currSum</span> <span class="o">+=</span> <span class="n">i</span>
      
    <span class="c1"># If (current sum - k) is in memo, then we found subarray(s) having sum = k</span>
    <span class="c1"># from index of the sum = current sum - k to index of the current sum.</span>
    <span class="c1"># The number of subarray(s) found is the frequency of the sum = current sum - k.</span>
    <span class="k">if</span> <span class="n">currSum</span> <span class="o">-</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
      <span class="n">count</span> <span class="o">+=</span> <span class="n">memo</span><span class="p">[</span><span class="n">currSum</span><span class="o">-</span><span class="n">k</span><span class="p">]</span>
        
    <span class="n">memo</span><span class="p">[</span><span class="n">currSum</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
      
  <span class="k">return</span> <span class="n">count</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Find the number of continuous subarrays of an array whose sum is divisible by k. </span>
<span class="sd">  Time complexity = O(n)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    nums: list</span>
<span class="sd">          The input array</span>
<span class="sd">    k   : int</span>
<span class="sd">          Given divisor of subarrays</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    count: int</span>
<span class="sd">           The number of subarrays</span>

<span class="sd">  Examples:</span>
<span class="sd">  --------- </span>
<span class="sd">    Given an array [4,5,0,-2,-3,1] with given divisor k = 5. </span>
<span class="sd">    Subarrays that have sum % 5 = 0 are:</span>
<span class="sd">    [5], [5,0], [0], [5,0,-2,-3], [0,-2,-3], [-2,-3], [4,5,0,-2,-3,1].</span>

<span class="sd">    How the algorithm works?</span>

<span class="sd">    The array of cumulative sum is [0,4,9,9,7,4,5]</span>
<span class="sd">    The array of cumulative sum mod K is [0,4,4,4,2,4,0]</span>
<span class="sd">    In the algorithm, turn the array into dictionary of cumulative sum mod K and its frequency:</span>
<span class="sd">      memo = {0: 2, 4: 4, 2: 1}</span>

<span class="sd">    For every cumulative sum (called current sum), if (currSum % k) is in memo, </span>
<span class="sd">    then we found subarray(s) having subarraySum % k = 0 from index of </span>
<span class="sd">    the sum = currSum - subarraySum to index of currSum.</span>

<span class="sd">                      currSum % k = (currSum - subarraySum) % k</span>
<span class="sd">                              =&gt; subarraySum % k = 0</span>

<span class="sd">    The number of subarray(s) found is the frequency of the sum = currSum % k.</span>

<span class="sd">    i = 4  -&gt; currSum = 4 -&gt; currSum % k = 4 not in memo -&gt; ignore</span>
<span class="sd">    i = 5  -&gt; currSum = 9 -&gt; currSum % k = 4 in memo     -&gt; count = 1, found [5]</span>
<span class="sd">    i = 0  -&gt; currSum = 9 -&gt; currSum % k = 4 in memo     -&gt; count = 3, found [5,0], [0]</span>
<span class="sd">    i = -2 -&gt; currSum = 7 -&gt; currSum % k = 2 not in memo -&gt; ignore</span>
<span class="sd">    i = -3 -&gt; currSum = 4 -&gt; currSum % k = 4 in memo     -&gt; count = 6, found [5,0,-2,-3], [0,-2,-3], [-2,-3]</span>
<span class="sd">    i = 1  -&gt; currSum = 5 -&gt; currSum % k = 0 in memo     -&gt; count = 7, found [4,5,0,-2,-3,1].</span>

<span class="sd">    &gt;&gt;&gt; nums = [4,5,0,-2,-3,1]</span>
<span class="sd">    &gt;&gt;&gt; k = 5</span>
<span class="sd">    &gt;&gt;&gt; print(SubarraySum_DivByK(nums, k))</span>
<span class="sd">    7</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">SubarraySum_DivByK</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
  <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
    
  <span class="n">memo</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="c1"># Memoization as: cumulativeSum mod K -&gt; Frequency</span>
  <span class="n">memo</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    
  <span class="n">currSum</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Current cumulative sum </span>
  <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># Number of continuous subarrays whose sum is divisible by K</span>
    
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
    <span class="n">currSum</span> <span class="o">+=</span> <span class="n">i</span>     
      
    <span class="c1"># If (currSum % k) is in memo, then we found subarray(s) having subarraySum % k = 0</span>
    <span class="c1">#   from index of the sum = currSum - subarraySum to index of currSum.</span>
    <span class="c1"># currSum % k = (currSum - subarraySum) % k</span>
    <span class="c1">#   =&gt; subarraySum % k = 0</span>
    <span class="k">if</span> <span class="n">currSum</span> <span class="o">%</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">memo</span><span class="p">:</span>
      <span class="c1"># The number of subarray(s) found is the frequency of the sum = currSum % k.</span>
      <span class="n">count</span> <span class="o">+=</span> <span class="n">memo</span><span class="p">[</span><span class="n">currSum</span> <span class="o">%</span> <span class="n">k</span><span class="p">]</span>
      
    <span class="n">memo</span><span class="p">[</span><span class="n">currSum</span> <span class="o">%</span> <span class="n">k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
  
  <span class="k">return</span> <span class="n">count</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="subsequence-problems">
<h2>Subsequence Problems<a class="headerlink" href="#subsequence-problems" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="14">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/LongestCommonSubsequence.ipynb"><span class="xref myst">Longest Common Subsequence (LCS)</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/LongestCommonSubsequence.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find the longest string S, every character in S is also in S1 and S2 but in order - <strong>O(|S1|.|S2|)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/Longest_Increasing_Subsequence.ipynb"><span class="xref myst">Longest Increasing/Decreasing Subsequence (Patience Sorting Algorithm)</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/Longest_Increasing_Subsequence.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find the Longest Increasing or Decreasing Subsequence of an Array List based on Patience Sorting Algorithm- <strong>O(n.log(n))</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find Longest Common Subsequence of 2 lists of string</span>
<span class="sd">  Time complexity = O(|L1|.|L2|), |L| is length of string list</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    strList1: list</span>
<span class="sd">              The first input string list </span>
<span class="sd">    strList2: list</span>
<span class="sd">              The second input string list  </span>
<span class="sd">    output  : &#39;stringList&#39; (default) or &#39;length&#39;, optional</span>
<span class="sd">              Type of output: max string list or max length</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    output = &#39;stringList&#39;: list</span>
<span class="sd">                           List of characters of ONLY 1 longest subsequence (there maybe more)</span>
<span class="sd">    output = &#39;length&#39;    : int</span>
<span class="sd">                           Length of longest subsequence </span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">            T E  R   R   A   C   E     D     |    T E R R A C E D</span>
<span class="sd">          C - -  -   -   -   C   C     C     |  C 0 0 0 0 0 1 1 1</span>
<span class="sd">          R - -  R   R   R   R   R     R     |  R 0 0 1 1 1 1 1 1</span>
<span class="sd">          A - -  R   R   RA  RA  RA    RA    |  A 0 0 1 1 2 2 2 2</span>
<span class="sd">          T T T  R   R   RA  RA  RA    RA    |  T 1 1 1 1 2 2 2 2</span>
<span class="sd">          E T TE TE  TE  RA  RA  RAE   [RAE] |  E 1 2 2 2 2 2 3 3</span>
<span class="sd">          R T TE TER TER TER TER [TER] [TER] |  R 1 2 3 3 3 3 3 3*</span>

<span class="sd">      Both &#39;RAE&#39; and &#39;TER&#39; are longest subsequences. This algorithm only returns</span>
<span class="sd">      &#39;TER&#39; (right bottom of the table). To return more, please add 2 more neighbors</span>
<span class="sd">      of right bottom if they also have the same length.</span>

<span class="sd">    &gt;&gt;&gt; strList1 = &#39;T E R R A C E D&#39;.split()</span>
<span class="sd">    &gt;&gt;&gt; strList2 = &#39;C R A T E R&#39;.split()</span>
<span class="sd">    &gt;&gt;&gt; LCS = LongestCommonSubsequence(strList1,strList2,output=&#39;stringList&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(LCS)</span>
<span class="sd">    [&#39;T&#39;, &#39;E&#39;, &#39;R&#39;]</span>
<span class="sd">    &gt;&gt;&gt; maxLength = LongestCommonSubsequence(strList1,strList2,output=&#39;length&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(maxLength)</span>
<span class="sd">    3</span>

<span class="sd">    &gt;&gt;&gt; strList1 = list(&#39;SHINCHAN&#39;)</span>
<span class="sd">    &gt;&gt;&gt; strList2 = list(&#39;NOHARAAA&#39;)</span>
<span class="sd">    &gt;&gt;&gt; LCS = LongestCommonSubsequence(strList1,strList2,output=&#39;stringList&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(LCS)</span>
<span class="sd">    [&#39;N&#39;, &#39;H&#39;, &#39;A&#39;]</span>

<span class="sd">    &gt;&gt;&gt; strList1 = &#39;16 27 60 76 123 88 55 94 57&#39;.split()</span>
<span class="sd">    &gt;&gt;&gt; strList2 = &#39;27 76 88 0 55 2 94 70 34 42 47&#39;.split()</span>
<span class="sd">    &gt;&gt;&gt; LCS = LongestCommonSubsequence(strList1,strList2,output=&#39;stringList&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(LCS)</span>
<span class="sd">    [&#39;27&#39;, &#39;76&#39;, &#39;88&#39;, &#39;55&#39;, &#39;94&#39;]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">LongestCommonSubsequence</span><span class="p">(</span><span class="n">strList1</span><span class="p">,</span> <span class="n">strList2</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;stringList&#39;</span><span class="p">):</span>
  <span class="c1"># Choose the longer length </span>
  <span class="n">L</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">strList1</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">strList2</span><span class="p">))</span> 
  <span class="c1"># Dynamic programming memory for lengths</span>
  <span class="n">dp_L</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
  <span class="c1"># Dynamic programming memory for strings</span>
  <span class="n">dp_S</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[[]]</span><span class="o">*</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">strList1</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">strList2</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">strList1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">strList2</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
        <span class="n">dp_L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp_L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">dp_S</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp_S</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">strList1</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">dp_L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">dp_L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span><span class="n">dp_L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">dp_L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">dp_L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span> <span class="n">dp_S</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp_S</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span> <span class="n">dp_S</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp_S</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

  <span class="c1"># 2 ways of output: max string lists or max lengths</span>
  <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;stringList&#39;</span><span class="p">:</span> 
    <span class="c1"># ONLY 1 longest subsequence, modify codes to return more</span>
    <span class="k">return</span> <span class="n">dp_S</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">strList1</span><span class="p">)][</span><span class="nb">len</span><span class="p">(</span><span class="n">strList2</span><span class="p">)]</span> 
  <span class="k">elif</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;length&#39;</span><span class="p">:</span> 
    <span class="k">return</span> <span class="n">dp_L</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">strList1</span><span class="p">)][</span><span class="nb">len</span><span class="p">(</span><span class="n">strList2</span><span class="p">)]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find Longest Increasing/Decreasing Subsequence of an array based on patience sorting</span>
<span class="sd">  Time complexity = O(n.log(n))</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    arr     : list</span>
<span class="sd">              Input array of numbers</span>
<span class="sd">    algoType: &#39;LIS&#39; (by default) or &#39;LDS&#39;, optional</span>
<span class="sd">              Algorithm type: Longest Increasing Subsequence (LIS)</span>
<span class="sd">              or Longest Decreasing Subsequence (LDS)</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    result: tuple</span>
<span class="sd">            A tuple of length of LIS, LIS and its indices in input array</span>
<span class="sd">            or length of LDS, LDS and its indices in input array</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">      Given an array list: </span>
<span class="sd">                          2  5  3  7  11  8  10  13  6</span>
<span class="sd">      LIS of this array is: </span>
<span class="sd">                         [2] 5 [3] [7] 11 [8] [10] [13] 6    =&gt; 6 elements</span>
<span class="sd">      Its position is:  </span>
<span class="sd">                          0     2   3      5   6    7</span>

<span class="sd">    &gt;&gt;&gt; arr = [2, 5, 3, 7, 11, 8, 10, 13, 6] </span>
<span class="sd">    &gt;&gt;&gt; print(Longest_Increasing_Subsequence(arr))</span>
<span class="sd">    (6, [2, 3, 7, 8, 10, 13], [0, 2, 3, 5, 6, 7])</span>

<span class="sd">    &gt;&gt;&gt; print(Longest_Increasing_Subsequence(arr, algoType=&#39;LDS&#39;))</span>
<span class="sd">    (3, [11, 8, 6], [4, 5, 8])</span>
<span class="sd">&#39;&#39;&#39;</span>
   
<span class="k">def</span><span class="w"> </span><span class="nf">Longest_Increasing_Subsequence</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">algoType</span><span class="o">=</span><span class="s1">&#39;LIS&#39;</span><span class="p">):</span>  
  <span class="c1"># Convert input for algorithm type: Longest Increasing Subsequence (LIS) or Longest Decreasing Subsequence (LDS)</span>
  <span class="k">if</span> <span class="n">algoType</span> <span class="o">==</span> <span class="s1">&#39;LIS&#39;</span><span class="p">:</span> 
    <span class="k">pass</span>
  <span class="k">elif</span> <span class="n">algoType</span> <span class="o">==</span> <span class="s1">&#39;LDS&#39;</span><span class="p">:</span> 
    <span class="n">arr</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

  <span class="c1"># Modified binary search </span>
  <span class="k">def</span><span class="w"> </span><span class="nf">GetCeilIndex</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span> 
    <span class="k">while</span> <span class="n">r</span> <span class="o">-</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> 
      <span class="n">m</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
      <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">T</span><span class="p">[</span><span class="n">m</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">key</span><span class="p">:</span> 
        <span class="n">r</span> <span class="o">=</span> <span class="n">m</span> 
      <span class="k">else</span><span class="p">:</span> 
        <span class="n">l</span> <span class="o">=</span> <span class="n">m</span> 
    <span class="k">return</span> <span class="n">r</span>   

  <span class="c1"># Initialized with 0 </span>
  <span class="n">tailIndices</span> <span class="o">=</span><span class="p">[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>    
  <span class="c1"># Initialized with -1 </span>
  <span class="n">prevIndices</span> <span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>   
      
  <span class="c1"># It will always point to empty location </span>
  <span class="n">length</span> <span class="o">=</span> <span class="mi">1</span> 
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>      
    <span class="k">if</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arr</span><span class="p">[</span><span class="n">tailIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]:</span>          
      <span class="c1"># New smallest value </span>
      <span class="n">tailIndices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> 

    <span class="k">elif</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">arr</span><span class="p">[</span><span class="n">tailIndices</span><span class="p">[</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span>           
      <span class="c1"># arr[i] wants to extend largest subsequence </span>
      <span class="n">prevIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tailIndices</span><span class="p">[</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
      <span class="n">tailIndices</span><span class="p">[</span><span class="n">length</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> 
      <span class="n">length</span> <span class="o">+=</span> <span class="mi">1</span>
          
    <span class="k">else</span><span class="p">:</span> 
      <span class="c1"># arr[i] wants to be a potential condidate of future subsequence </span>
      <span class="c1"># It will replace ceil value in tailIndices </span>
      <span class="n">pos</span> <span class="o">=</span> <span class="n">GetCeilIndex</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">tailIndices</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> 
      <span class="n">prevIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tailIndices</span><span class="p">[</span><span class="n">pos</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
      <span class="n">tailIndices</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> 
          
  <span class="c1"># Construct Longest Increasing Subsequence and its indices </span>
  <span class="k">if</span> <span class="n">algoType</span> <span class="o">==</span> <span class="s1">&#39;LIS&#39;</span><span class="p">:</span>
    <span class="n">LIS</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">LIS_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">tailIndices</span><span class="p">[</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> 
      <span class="n">LIS</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="n">LIS_idx</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">i</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">prevIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 

    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">LIS</span><span class="p">,</span> <span class="n">LIS_idx</span><span class="p">)</span>

  <span class="c1"># Construct Longest Decreasing Subsequence and its indices</span>
  <span class="k">elif</span> <span class="n">algoType</span> <span class="o">==</span> <span class="s1">&#39;LDS&#39;</span><span class="p">:</span>
    <span class="n">LDS</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">LDS_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">tailIndices</span><span class="p">[</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">while</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span> 
      <span class="n">LDS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
      <span class="n">LDS_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
      <span class="n">i</span> <span class="o">=</span> <span class="n">prevIndices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> 

    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">LDS</span><span class="p">,</span> <span class="n">LDS_idx</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="substring-problems">
<h2>Substring Problems<a class="headerlink" href="#substring-problems" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="16">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/Longest_Common_Substring.ipynb"><span class="xref myst">Longest Common Substring (Longest Common Factor - LCF)</span></a>: Find the Longest Common Substring (Factor) of 2 strings S1 and S2 - <strong>O(|S1|.|S2|)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Dynamic%20Programming/SumOfSubstrings.ipynb"><span class="xref myst">Sum Of Substrings</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/SumOfSubstrings.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find Sum of All Substrings of an Number String S - <strong>O(|S|)</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find Longest Common Substring (Factor) of 2 strings</span>
<span class="sd">  Time complexity = O(m.n); m = |S1| and n = |S2|</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    s1      : string</span>
<span class="sd">              The first input string </span>
<span class="sd">    s2      : list</span>
<span class="sd">              The second input string list  </span>
<span class="sd">    output  : &#39;substring&#39; (default) or &#39;position&#39;, optional</span>
<span class="sd">              Type of output: common substring or its position</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    output = &#39;substring&#39;: string</span>
<span class="sd">                          Longest common substring</span>
<span class="sd">    output = &#39;position&#39; : int</span>
<span class="sd">                          Substring&#39;s position in s1 and s2</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; s1 = &#39;helloworld&#39;</span>
<span class="sd">    &gt;&gt;&gt; s2 = &#39;yellomarin&#39;</span>
<span class="sd">    &gt;&gt;&gt; LCS = LongestCommonSubstring(s1, s2, output = &#39;substring&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(LCS)</span>
<span class="sd">    ello</span>

<span class="sd">    &gt;&gt;&gt; s1 = &#39;tabriz&#39;</span>
<span class="sd">    &gt;&gt;&gt; s2 = &#39;torino&#39;</span>
<span class="sd">    &gt;&gt;&gt; posS1, posS2 = LongestCommonSubstring(s1, s2, output = &#39;position&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(posS1)</span>
<span class="sd">    [3, 4]</span>
<span class="sd">    &gt;&gt;&gt; print(posS2)</span>
<span class="sd">    [2, 3]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">LongestCommonSubstring</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="s1">&#39;substring&#39;</span><span class="p">):</span>
  <span class="n">dp</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> 
  <span class="n">longest</span><span class="p">,</span> <span class="n">i_longest</span><span class="p">,</span> <span class="n">j_longest</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>

  <span class="c1"># Main algorithm</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">s1</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">s2</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
      <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">longest</span><span class="p">:</span>
        <span class="n">longest</span> <span class="o">=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
        <span class="n">i_longest</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">j_longest</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
  
  <span class="c1"># 2 ways of output: substring or its position</span>
  <span class="k">if</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;substring&#39;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">s1</span><span class="p">[</span><span class="n">i_longest</span> <span class="o">-</span> <span class="n">longest</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">i_longest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
  <span class="k">elif</span> <span class="n">output</span> <span class="o">==</span> <span class="s1">&#39;position&#39;</span><span class="p">:</span>
    <span class="n">pos_s1</span> <span class="o">=</span> <span class="p">[</span><span class="n">i_longest</span> <span class="o">-</span> <span class="n">longest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i_longest</span><span class="p">]</span> 
    <span class="n">pos_s2</span> <span class="o">=</span> <span class="p">[</span><span class="n">j_longest</span> <span class="o">-</span> <span class="n">longest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j_longest</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">pos_s1</span><span class="p">,</span> <span class="n">pos_s2</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find Sum of all Substrings of an number string</span>
<span class="sd">  Time complexity = O(|s|)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    s: string</span>
<span class="sd">       Input number string</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    An integer sum of of all number substrings </span>

<span class="sd">  Examples:</span>
<span class="sd">  --------- </span>
<span class="sd">    The sub-strings of 123 are 1, 2, 3, 12, 23, 123 which sums to 164</span>

<span class="sd">    &gt;&gt;&gt; t = SumOfSubstrings(&#39;123&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(t)</span>
<span class="sd">    164</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">SumOfSubstrings</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
  <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
  <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
    <span class="c1"># If mod(10^9+7) is required, then add in</span>
    <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">10</span><span class="o">*</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    
  <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
</section>
</section>
<section id="f-two-pointers-sliding-window">
<h1>F) Two Pointers - Sliding Window<a class="headerlink" href="#f-two-pointers-sliding-window" title="Link to this heading">#</a></h1>
<section id="non-categorized">
<h2>Non-categorized<a class="headerlink" href="#non-categorized" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Two%20Pointers%20-%20Sliding%20Window/LongestSubstring_0RepeatChars.ipynb"><span class="xref myst">Longest Substring Without Repeating Characters</span></a><sup><a class="reference external" href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">[Leetcode]</a></sup>: Find the Length of the Longest Substring Without Repeating Characters  - <strong>O(|S|)</strong></p></li>
</ul>
</li>
</ol>
</section>
<section id="visualization-of-how-the-algorithm-works">
<h2>Visualization of how the algorithm works<a class="headerlink" href="#visualization-of-how-the-algorithm-works" title="Link to this heading">#</a></h2>
<p><img alt="Longest Substring Without Repeating Characters.png" src="data:image/png;base64,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" /></p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Find the length of the longest substring without repeating characters </span>
<span class="sd">  Time complexity = O(n)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    s: str</span>
<span class="sd">       The input string</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    Longest length: int</span>

<span class="sd">  Examples:</span>
<span class="sd">  --------- </span>
<span class="sd">    Given a string &#39;ABCBFAC&#39;. </span>
<span class="sd">    The longest substring without repeating characters is &#39;BFAC&#39;, and its length is 4.</span>

<span class="sd">    How the algorithm works?</span>
<span class="sd">      See the markdown cell above</span>

<span class="sd">    &gt;&gt;&gt; s = &#39;ABCBFAC&#39;</span>
<span class="sd">    &gt;&gt;&gt; print(LongestSubstring_0RepeatChars(s))</span>
<span class="sd">    4</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">LongestSubstring_0RepeatChars</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>
    
    <span class="n">d</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span> <span class="c1"># Memoization as: character -&gt; its indices</span>
    <span class="n">memo</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Memoization of lengths</span>
    <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="c1"># Two pointers</span>
    
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
      <span class="n">c</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="c1"># Current character</span>
      <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">i</span><span class="p">:</span>
          <span class="n">memo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="p">)</span> <span class="c1"># memo.append([j-i, i, j]) if you wanna output the substring</span>
          <span class="n">i</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>      
      <span class="n">d</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>    
    
    <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
      <span class="n">memo</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>  
      <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">memo</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="mi">0</span> 
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
</section>
</section>
<section id="g-mathematics">
<h1>G) Mathematics<a class="headerlink" href="#g-mathematics" title="Link to this heading">#</a></h1>
<section id="binomial-coefficient-problems">
<h2>Binomial Coefficient Problems<a class="headerlink" href="#binomial-coefficient-problems" title="Link to this heading">#</a></h2>
<ol class="arabic simple">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/Pascal_Triangle.ipynb"><span class="xref myst">Pascal Triangle</span></a>: Create Pascal Triangle (to Calculate Multiple Large-Number Combinations) - <strong>O(n<sup>2</sup>)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/Lattice_Paths.ipynb"><span class="xref myst">PE #15: Lattice Paths</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/Lattice_Paths.pdf"><span class="xref myst">[PDF]</span></a></sup> : Find the number of routes from the top left corner to the bottom right corner in a rectangular grid</p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to create Pascal Triangle, used to calculate multiple large-number combinations</span>
<span class="sd">  Time complexity = O(n^2)</span>
<span class="sd">  Space complexity = O((n+1)(n+2)/2)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    N: integer</span>
<span class="sd">       Size of Pascal Triangle</span>
<span class="sd">  </span>
<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    t: list</span>
<span class="sd">       All rows of Pascal Triangle</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">          For N = 4:</span>
<span class="sd">              1           n = 0               0C0</span>
<span class="sd">            1   1         n = 1            1C0   1C1</span>
<span class="sd">          1   2   1       n = 2         2C0   2C1   2C2 </span>
<span class="sd">        1   3   3   1     n = 3      3C0   3C1   3C2   3C3</span>
<span class="sd">      1   4   6   4   1   n = 4   4C0   4C1   4C2   4C3   4C4</span>

<span class="sd">    &gt;&gt;&gt; t = Pascal_Triangle(4)</span>
<span class="sd">    &gt;&gt;&gt; print(t)</span>
<span class="sd">    [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Pascal_Triangle</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
  <span class="n">t</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Full triangle</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># Row i of triangle t</span>
    <span class="n">t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span> <span class="c1"># nC0 = nCn = 1</span>
        <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

  <span class="k">return</span> <span class="n">t</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">factorial</span> <span class="k">as</span> <span class="n">f</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Lattice_Paths</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">):</span>
  <span class="n">res</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="n">m</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="n">m</span><span class="p">))</span> <span class="c1"># (n+m)C(n) or (n+m)C(m)</span>
  <span class="k">return</span> <span class="n">res</span><span class="o">%</span><span class="p">(</span><span class="mi">10</span><span class="o">**</span><span class="mi">9</span><span class="o">+</span><span class="mi">7</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())):</span>
    <span class="n">nm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span><span class="nb">input</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
    <span class="n">n</span><span class="p">,</span><span class="n">m</span> <span class="o">=</span> <span class="n">nm</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">Lattice_Paths</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="factors-problems">
<h2>Factors Problems<a class="headerlink" href="#factors-problems" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="3">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/Factorization.ipynb"><span class="xref myst">Factorization</span></a>: Find All Factors of a Number - <strong>O(n<sup>1/2</sup>)</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find all factors of an integer</span>
<span class="sd">  Time complexity = O(sqrt(n))</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    n: integer</span>
<span class="sd">       Input number </span>
<span class="sd">    </span>
<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    factors: list</span>
<span class="sd">             All factors of the number n</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; factors = Factorization(10)</span>
<span class="sd">    &gt;&gt;&gt; print(factors)</span>
<span class="sd">    [1, 10, 2, 5]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Factorization</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="n">factors</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">div</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="n">div</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">div</span><span class="p">)</span>

      <span class="n">other</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="n">div</span>
      <span class="k">if</span> <span class="n">other</span> <span class="o">!=</span> <span class="n">div</span><span class="p">:</span>
        <span class="n">factors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

  <span class="k">return</span> <span class="n">factors</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="multiples-problems">
<h2>Multiples Problems<a class="headerlink" href="#multiples-problems" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="4">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/Multiples_of_3_and_5.ipynb"><span class="xref myst">PE #1: Multiples of 3 and 5</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/Multiples_of_3_and_5.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find Sum of Multiples of a Number - <strong>O(1)</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">SumOfMultiples</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
  
  <span class="n">sum_of_3</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">n</span><span class="o">//</span><span class="mi">3</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
  <span class="n">sum_of_5</span> <span class="o">=</span> <span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">n</span><span class="o">//</span><span class="mi">5</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
  <span class="n">sum_of_15</span> <span class="o">=</span> <span class="mi">15</span><span class="o">*</span><span class="p">(</span><span class="n">n</span><span class="o">//</span><span class="mi">15</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">n</span><span class="o">//</span><span class="mi">15</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span>
  
  <span class="nb">sum</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sum_of_3</span> <span class="o">+</span> <span class="n">sum_of_5</span> <span class="o">-</span> <span class="n">sum_of_15</span><span class="p">)</span>
      
  <span class="k">return</span> <span class="nb">sum</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
  <span class="n">t</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
  
  <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">input</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">SumOfMultiples</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="permutation-problems">
<h2>Permutation Problems<a class="headerlink" href="#permutation-problems" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="5">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/Lexicographic_Permutations.ipynb"><span class="xref myst">Lexicographic Permutations</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/Lexicographic_Permutations.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find n-th Lexicographic Permutation of a very long Word - <strong>O(n)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/arePermutations.ipynb"><span class="xref myst">Permutation Check</span></a>: Check if 2 Numbers/Strings are Permutations - <strong>O(n)</strong> , n = max(|a|,|b|)</p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find n-th Lexicographic Permutation of a very long word</span>
<span class="sd">  Time complexity = O(n) </span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    word: string</span>
<span class="sd">          Input word to find permutation </span>
<span class="sd">    n   : integer</span>
<span class="sd">          Order of Lexicographic Permutation</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    word_perm: string</span>
<span class="sd">               n-th permutated word</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    The Lexicographic Permutations of &#39;abc&#39; are:</span>
<span class="sd">    &#39;abc&#39;, &#39;acb&#39;, &#39;bac&#39;, &#39;bca&#39;, &#39;cab&#39;, &#39;cba&#39;</span>
<span class="sd">      1      2      3      4      5      6    (= 3!)</span>

<span class="sd">    &gt;&gt;&gt; word = &#39;abc&#39;</span>
<span class="sd">    &gt;&gt;&gt; word_perm = Lexicographic_Permutations(word,4)</span>
<span class="sd">    &gt;&gt;&gt; print(word_perm)</span>
<span class="sd">    bca</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">factorial</span> <span class="k">as</span> <span class="n">f</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Lexicographic_Permutations</span><span class="p">(</span><span class="n">word</span><span class="p">,</span><span class="n">n</span><span class="p">):</span> 
  <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span> <span class="c1"># First order of permutation is 1, not 0</span>
  <span class="n">queue</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
  <span class="n">word_perm</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
  <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>

  <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">n</span><span class="o">//</span><span class="n">f</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
    <span class="n">word_perm</span> <span class="o">+=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">-=</span> <span class="n">pos</span><span class="o">*</span><span class="n">f</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
  
  <span class="k">return</span> <span class="n">word_perm</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to check if 2 numbers/strings are permutations</span>
<span class="sd">  Time complexity = O(n.logn), n = max(|a|,|b|)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    a: integer or string</span>
<span class="sd">       First input  </span>
<span class="sd">    b: integer or string</span>
<span class="sd">       Second input</span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    True/False: boolean</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; a = &#39;AEF&#39;</span>
<span class="sd">    &gt;&gt;&gt; b = &#39;FEAF&#39;</span>
<span class="sd">    &gt;&gt;&gt; print(arePermutations(a,b)) </span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; a = 1432</span>
<span class="sd">    &gt;&gt;&gt; b = 4312</span>
<span class="sd">    &gt;&gt;&gt; print(arePermutations(a,b))</span>
<span class="sd">    True</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">arePermutations</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
  <span class="c1"># Decompose input into a sorted list of characters</span>
  <span class="n">la</span><span class="p">,</span> <span class="n">lb</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)),</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">b</span><span class="p">))</span> 

  <span class="k">if</span> <span class="n">la</span> <span class="o">==</span> <span class="n">lb</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">True</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="primes-problems">
<h2>Primes Problems<a class="headerlink" href="#primes-problems" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="7">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/Sieve_All_Primes.ipynb"><span class="xref myst">“Sieve Method” All Primes</span></a>: Find All Primes &lt; n - <strong>Space = O(n<sup>1/2</sup>)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/isPrime.ipynb"><span class="xref myst">Primality Test (Common Method)</span></a>: Check if n is a Prime Number using “Common Method” - <strong>O(n<sup>1/2</sup>)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/isPrime_Miller_Rabin.ipynb"><span class="xref myst">Primality Test (Miller-Rabin)</span></a>: Check if n is a Prime Number using Miller-Rabin Probabilistic Test - <strong>O(k.log<sup>3</sup>n)</strong> , k = [1,2,…]</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/areCoprimes.ipynb"><span class="xref myst">Coprimes Check</span></a>: Check if 2 Numbers are Coprime - <strong>O(log a.b)</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to find all primes &lt; n using &quot;Sieve Method&quot;</span>
<span class="sd">  Time complexity = O(sqrt(n))</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    n: integer</span>
<span class="sd">       Input positive number </span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    primes: list</span>
<span class="sd">            All prime numbers &lt; n</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; primes = Sieve_All_Primes(11)</span>
<span class="sd">    &gt;&gt;&gt; print(primes)</span>
<span class="sd">    [2, 3, 5, 7]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Sieve_All_Primes</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="n">sieve</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
      <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">::</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">//</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
  
  <span class="c1"># Output the list of all primes</span>
  <span class="n">primes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="k">if</span> <span class="n">sieve</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
  <span class="k">return</span> <span class="n">primes</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to check if a number is prime using &quot;Common Method&quot;</span>
<span class="sd">  Time complexity = O(sqrt(n))</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    n: integer</span>
<span class="sd">       Input number </span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    True/False: boolean</span>

<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">isPrime</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span> <span class="k">return</span> <span class="kc">True</span>
  <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="k">2</span> == 0 or n &lt; 2: return False
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span> <span class="c1"># Only odd numbers</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="k">i</span> == 0:
      <span class="k">return</span> <span class="kc">False</span>    

  <span class="k">return</span> <span class="kc">True</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to check if a number is prime based on Miller-Rabin probabilistic test</span>
<span class="sd">  Time complexity = O(k.(logn)^3)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    n: integer</span>
<span class="sd">       Input number to be checked</span>
<span class="sd">    k: integer, optional</span>
<span class="sd">       Constant adjusted to balance accuracy/speed (default: k = 3)</span>
<span class="sd">       Highly recommend to try multiple k to get best outcome   </span>

<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    PFs: set</span>
<span class="sd">         All prime factors of the number x</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; n = 11</span>
<span class="sd">    &gt;&gt;&gt; print(isPrime_Miller_Rabin(n, k=3)) </span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; # Experiment to find best &#39;k&#39;</span>
<span class="sd">    &gt;&gt;&gt; primes = Sieve_All_Primes(10**5)</span>
<span class="sd">    &gt;&gt;&gt; for n in primes:</span>
<span class="sd">    &gt;&gt;&gt;   if isPrime(n) != isPrime_Miller_Rabin(n, k=3):</span>
<span class="sd">    &gt;&gt;&gt;     print(&#39;k=3 cannot assure the accuracy, please adjust k&#39;)</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="k">def</span><span class="w"> </span><span class="nf">isPrime_Miller_Rabin</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
  <span class="c1"># Adjust &quot;k&quot; to trade-off speed/accuraccy</span>
  <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>  <span class="c1"># Assuming n &gt;= 0 in all cases... shortcut small cases here</span>
    <span class="k">return</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">][</span><span class="n">n</span><span class="p">]</span>
  <span class="k">elif</span> <span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Should be faster than n % 2</span>
    <span class="k">return</span> <span class="kc">False</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">d</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">s</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">d</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span>
    <span class="c1"># Use random.randint(2, n-2) for very large numbers</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">random</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)),</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">4</span><span class="p">,</span> <span class="n">k</span><span class="p">)):</span>
      <span class="n">x</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">n</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
          <span class="n">x</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
          <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Composite for sure</span>
          <span class="k">elif</span> <span class="n">x</span> <span class="o">==</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># So we know loop didn&#39;t continue to end</span>
            <span class="k">break</span>  <span class="c1"># Could be strong liar, try another a</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">:</span>
          <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Composite if we reached end of this loop</span>
    <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Probably prime if reached end of outer loop</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to check if two numbers are coprime</span>
<span class="sd">  Time complexity = O(log a.b)</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    a: integer</span>
<span class="sd">       First input number </span>
<span class="sd">    b: integer</span>
<span class="sd">       Second input number</span>
<span class="sd">       </span>
<span class="sd">  Returns:</span>
<span class="sd">  --------</span>
<span class="sd">    True/False: boolean</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="k">def</span><span class="w"> </span><span class="nf">areCoprimes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
</section>
<section id="primes-factors-problems">
<h2>Primes-Factors Problems<a class="headerlink" href="#primes-factors-problems" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="11">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/Euler_Totient_NumList.ipynb"><span class="xref myst">Euler Totient Function (Number List)</span></a>: Find ALL Numbers of Coprimes &lt; n based on Euler Totient Function - <strong>O((l) + m.loglogm + l.(logm + k))</strong> , k is the number of prime factors of n; m and l is max value and length of the input number list</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/Euler_Totient_SingleNum.ipynb"><span class="xref myst">Euler Totient Function (Single Number)</span></a>: Find the Number of Coprimes &lt; n based on Euler Totient Function - <strong>O(n<sup>1/2</sup> + k)</strong> , k is the number of prime factors of the input number n</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/Sieve_SPF.ipynb"><span class="xref myst">“Sieve Method” Smallest Prime Factors (SPF)</span></a>: Find Smallest Prime Factors for All Numbers &lt; N - <strong>O(n.loglogn)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/PrimeFactorization_SPF.ipynb"><span class="xref myst">Prime Factorization (Smallest Prime Factor)</span></a>: Find All Prime Factors of a Number using Smallest Prime Factor (SPF) - <strong>O(log n)</strong> if a list of all Smallest Prime Factors from 0 to n available</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/PrimeFactorization.ipynb"><span class="xref myst">Prime Factorization</span></a>: Find All Prime Factors of a Number - <strong>O(n<sup>1/2</sup>)</strong></p></li>
</ul>
</li>
</ol>
</section>
<section id="pythagorean-theorem">
<h2>Pythagorean Theorem<a class="headerlink" href="#pythagorean-theorem" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="16">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/PythagoreanTriplets_Perimeter.ipynb"><span class="xref myst">Pythagorean Triplets Perimeter</span></a>: Find Pythagorean Triplets having Perimeter (or Sum) P - <strong>O(P)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/PythagoreanTriplets_LessEqualN.ipynb"><span class="xref myst">Pythagorean Triplets Less or Equal N</span></a>: Generate all Pythagorean Triplets &lt;= N - <strong>O(N.log(N))</strong></p></li>
</ul>
</li>
</ol>
</section>
<section id="id1">
<h2>Non-categorized<a class="headerlink" href="#id1" title="Link to this heading">#</a></h2>
<ol class="arabic simple" start="18">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Mathematics/Number_Spiral_Diagonals.ipynb"><span class="xref myst">Number Spiral Diagonals</span></a><sup><a class="reference internal" href="#../22SPAR-coding-all/Data%20Bank/Number_Spiral_Diagonals.pdf"><span class="xref myst">[PDF]</span></a></sup>: Find Sum of Diagonals of Ulam Spiral Matrix</p></li>
</ul>
</li>
</ol>
<hr class="docutils" />
</section>
</section>
<section id="h-linked-list">
<h1>H) Linked List<a class="headerlink" href="#h-linked-list" title="Link to this heading">#</a></h1>
<section id="singly-linked-list">
<h2>Singly-linked List<a class="headerlink" href="#singly-linked-list" title="Link to this heading">#</a></h2>
<blockquote>
<div><p>Problem statement: Do something on a given singly-linked List</p>
</div></blockquote>
<blockquote>
<div><p>Hints:</p>
<ol class="arabic simple">
<li><p>Simply convert linked list to 1D array and solve on the array using “ListNode_to_Array”</p></li>
<li><p>If necessary, convert 1D array back to the linked list using “Array_to_ListNode”</p></li>
</ol>
</div></blockquote>
<ol class="arabic simple">
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Linked%20List/ListNode.ipynb"><span class="xref myst">List Node</span></a>: Create a Singly-linked List using “Node class”</p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Linked%20List/ListNode_to_Array.ipynb"><span class="xref myst">ListNode to Array</span></a>: Convert ListNode into Array, could be used as print to “see” inside a ListNode - <strong>O(n)</strong></p></li>
</ul>
</li>
<li><ul class="contains-task-list simple">
<li class="task-list-item"><p><input class="task-list-item-checkbox" checked="checked" disabled="disabled" type="checkbox"> <a class="reference internal" href="#../22SPAR-coding-all/Linked%20List/Array_to_ListNode.ipynb"><span class="xref myst">Array to ListNode</span></a>: Convert Array into ListNode - <strong>O(n)</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to define a singly-linked list using &quot;Node class&quot;</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    val : integer</span>
<span class="sd">          Value of the node</span>
<span class="sd">    next: None or ListNode</span>
<span class="sd">          None or another node</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; root = ListNode()</span>
<span class="sd">    &gt;&gt;&gt; root.val = 1</span>
<span class="sd">    &gt;&gt;&gt; root.next = ListNode()</span>
<span class="sd">    &gt;&gt;&gt; print(root)</span>
<span class="sd">    &lt;__main__.ListNode object at 0x7d6c1624a5f0&gt;</span>

<span class="sd">    &gt;&gt;&gt; print(root.val)</span>
<span class="sd">    1</span>

<span class="sd">    &gt;&gt;&gt; print(root.next.val)</span>
<span class="sd">    0</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ListNode</span><span class="p">:</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to convert ListNode to Array</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    root : ListNode</span>
<span class="sd">           ListNode object</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; root = ListNode(0)</span>
<span class="sd">    &gt;&gt;&gt; root.next = ListNode(1)</span>
<span class="sd">    &gt;&gt;&gt; root.next.next = ListNode(2)</span>
<span class="sd">    &gt;&gt;&gt; print(ListNode_to_Array(root))</span>
<span class="sd">    [0, 1, 2]</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ListNode</span><span class="p">:</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>

<span class="k">def</span><span class="w"> </span><span class="nf">ListNode_to_Array</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>
  <span class="n">curr</span> <span class="o">=</span> <span class="n">root</span>
  <span class="n">arr</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
    <span class="n">arr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>
    <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span>

  <span class="k">return</span> <span class="n">arr</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Function to convert Array to ListNode</span>

<span class="sd">  Parameters:</span>
<span class="sd">  -----------</span>
<span class="sd">    root : ListNode</span>
<span class="sd">           ListNode object</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; arr = [0, 1, 2]</span>
<span class="sd">    &gt;&gt;&gt; root = Array_to_ListNode(arr)</span>
<span class="sd">    &gt;&gt;&gt; print(root.val, root.next.val, root.next.next.val)</span>
<span class="sd">    0 1 2</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ListNode</span><span class="p">:</span>
  <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">next</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="nb">next</span>

<span class="k">def</span><span class="w"> </span><span class="nf">Array_to_ListNode</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
  <span class="n">root</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
  <span class="n">curr</span> <span class="o">=</span> <span class="n">root</span>

  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
    <span class="n">curr</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
      <span class="n">curr</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">ListNode</span><span class="p">()</span>
      <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span><span class="o">.</span><span class="n">next</span>

  <span class="k">return</span> <span class="n">root</span>
</pre></div>
</div>
</div>
</div>
<hr class="docutils" />
</section>
</section>
<section id="i-matrix">
<h1>I) Matrix<a class="headerlink" href="#i-matrix" title="Link to this heading">#</a></h1>
<section id="matrix-x-simulation">
<h2>Matrix x Simulation<a class="headerlink" href="#matrix-x-simulation" title="Link to this heading">#</a></h2>
<blockquote>
<div><p>Problem statement: Move current position within the matrix along diagonals, up-down-right-left, …</p>
</div></blockquote>
<blockquote>
<div><p>Hints:</p>
<ol class="arabic simple">
<li><p>Use variable flag = ‘up’ or ‘down’ … to guide the current position to the next position</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span>
  <span class="c1"># Do something</span>
  <span class="c1"># Consider to change the flag = &#39;down&#39; or &#39;right&#39; or &#39;something&#39;</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li><p>Pay attention to the matrix boundary when moving</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">inMatrix</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">):</span>
  <span class="c1"># R, C is the matrix size</span>
  <span class="c1"># r, c is current position</span>
  <span class="k">if</span> <span class="n">r</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">C</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">True</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="kc">False</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p>Use variable seen = set() to not move to the seen position or to not start as a current position</p></li>
</ol>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
  <span class="c1"># Do something</span>
</pre></div>
</div>
</div></blockquote>
<ol class="arabic simple">
<li><ul class="simple">
<li><p>Find all elements of the matrix in spiral order - <strong>O(R.C)</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Solution to Spiral Matrix</span>
<span class="sd">  Find all elements of the matrix in spiral order</span>
<span class="sd">  Time complexity = O(R.C)</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; matrix = [[1,2,3],[4,5,6],[7,8,9]]</span>
<span class="sd">    &gt;&gt;&gt; print(spiralOrder(matrix))</span>
<span class="sd">    [1, 2, 3, 6, 9, 8, 7, 4, 5]</span>

<span class="sd">    &gt;&gt;&gt; matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]</span>
<span class="sd">    &gt;&gt;&gt; print(spiralOrder(matrix))</span>
<span class="sd">    [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span><span class="w"> </span><span class="nf">spiralOrder</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
  <span class="n">R</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># Size of matrix</span>

  <span class="n">flag</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span> <span class="c1"># Variable to guide to current position to next position</span>
  <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="c1"># Current position</span>

  <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># The path that the current position has moved</span>
  <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># To not move to the seen position</span>

  <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">*</span><span class="n">C</span><span class="p">:</span>
    <span class="c1">#print(path, r,c) # For debug</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
      <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">matrix</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">])</span>
      <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="n">C</span> <span class="ow">or</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span> <span class="c1"># If reach the matrix boundary or seen position, then go down</span>
        <span class="n">c</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="s1">&#39;down&#39;</span>

    <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;down&#39;</span><span class="p">:</span>
      <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="n">R</span> <span class="ow">or</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span> <span class="c1"># If reach the matrix boundary or seen position, then go left</span>
        <span class="n">r</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="s1">&#39;left&#39;</span>

    <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
      <span class="n">c</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span> <span class="c1"># If reach the matrix boundary or seen position, then go up</span>
        <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="s1">&#39;up&#39;</span>

    <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span>
      <span class="n">r</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span> <span class="c1"># If reach the seen position, then go right</span>
        <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="s1">&#39;right&#39;</span>

  <span class="k">return</span> <span class="n">path</span>
</pre></div>
</div>
</div>
</div>
<ol class="arabic simple" start="2">
<li><ul class="simple">
<li><p>Find all the elements of the array in a diagonal order - <strong>O(R.C)</strong></p></li>
</ul>
</li>
</ol>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">  Solution to Diagonal Traverse</span>
<span class="sd">  Find all the elements of the array in a diagonal order</span>
<span class="sd">  Time complexity = O(R.C)</span>

<span class="sd">  Examples:</span>
<span class="sd">  ---------</span>
<span class="sd">    &gt;&gt;&gt; mat = [[1,2,3],[4,5,6],[7,8,9]]</span>
<span class="sd">    &gt;&gt;&gt; print(findDiagonalOrder(mat))</span>
<span class="sd">    [1, 2, 4, 7, 5, 3, 6, 8, 9]</span>

<span class="sd">    &gt;&gt;&gt; mat = [[1,2],[3,4]]</span>
<span class="sd">    &gt;&gt;&gt; print(findDiagonalOrder(mat))</span>
<span class="sd">    [1, 2, 3, 4]</span>

<span class="sd">  References:</span>
<span class="sd">    https://leetcode.com/problems/diagonal-traverse</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span>

<span class="k">def</span><span class="w"> </span><span class="nf">findDiagonalOrder</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
  <span class="c1"># Diagonal extraction approach</span>

  <span class="n">R</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># Size of matrix</span>
  <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># To not start in a position that&#39;s already seen</span>
  <span class="n">reverse</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1"># A flag to reverse the diagonal as required in the problem statement</span>
  <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">C</span><span class="p">):</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>

        <span class="n">d</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Diagonal of a submatrix</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="c1"># Position of each element in a diagonal</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">R</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
          <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
          <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">))</span>
          <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
          <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># Decide whether to reverse the diagonal or not</span>
        <span class="k">if</span> <span class="n">reverse</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
          <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
          <span class="n">reverse</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">reverse</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">path</span> <span class="o">+=</span> <span class="n">d</span>

        <span class="c1">#print(r,c,d) # For debug</span>

  <span class="k">return</span> <span class="n">path</span>

<span class="k">def</span><span class="w"> </span><span class="nf">findDiagonalOrder</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
  <span class="c1"># Simulation approach</span>

  <span class="n">flag</span> <span class="o">=</span> <span class="s1">&#39;up&#39;</span>
  <span class="n">r</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
  <span class="n">R</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

  <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">*</span><span class="n">C</span><span class="p">:</span>
    <span class="c1">#print(r,c, flag, path) # For debug</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
      <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">r</span><span class="p">][</span><span class="n">c</span><span class="p">])</span>
      <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;up&#39;</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">r</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">c</span> <span class="o">==</span> <span class="n">C</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># If reach matrix boundary, then reverse the direction</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="s1">&#39;down&#39;</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">C</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
          <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">c</span> <span class="o">==</span> <span class="n">C</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
          <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">continue</span>
      <span class="n">r</span> <span class="o">-=</span> <span class="mi">1</span>
      <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">elif</span> <span class="n">flag</span> <span class="o">==</span> <span class="s1">&#39;down&#39;</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">r</span> <span class="o">==</span> <span class="n">R</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span> <span class="c1"># If reach matrix boundary, then reverse the direction</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="s1">&#39;up&#39;</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">R</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
          <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">r</span> <span class="o">==</span> <span class="n">R</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
          <span class="n">c</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">continue</span>
      <span class="n">r</span> <span class="o">+=</span> <span class="mi">1</span>
      <span class="n">c</span> <span class="o">-=</span> <span class="mi">1</span>

  <span class="k">return</span> <span class="n">path</span>
</pre></div>
</div>
</div>
</div>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./PE_Informatics"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">


  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#">A) Data Structures Applications</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#binary-search-tree-algorithm">Binary Search Tree Algorithm</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#b-string-algorithm">B) String Algorithm</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#suffix-tree-suffix-array">Suffix Tree - Suffix Array</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#c-searching-and-graph-algorithms">C) Searching and Graph Algorithms</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#graph-theory">Graph Theory</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#detect-cycle">Detect Cycle</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#graph-traversal">Graph Traversal</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-spanning-tree-mst">Minimum Spanning Tree (MST)</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#shortest-path">Shortest Path</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#d-greedy-algorithm">D) Greedy Algorithm</a></li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#e-dynamic-programming">E) Dynamic Programming</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#coin-change-algorithms">Coin Change Algorithms</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#knapsack-problems">Knapsack Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#path-sum-problems">Path Sum Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#subarray-problems">Subarray Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#subsequence-problems">Subsequence Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#substring-problems">Substring Problems</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#f-two-pointers-sliding-window">F) Two Pointers - Sliding Window</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#non-categorized">Non-categorized</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#visualization-of-how-the-algorithm-works">Visualization of how the algorithm works</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#g-mathematics">G) Mathematics</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#binomial-coefficient-problems">Binomial Coefficient Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#factors-problems">Factors Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#multiples-problems">Multiples Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#permutation-problems">Permutation Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#primes-problems">Primes Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#primes-factors-problems">Primes-Factors Problems</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#pythagorean-theorem">Pythagorean Theorem</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#id1">Non-categorized</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#h-linked-list">H) Linked List</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#singly-linked-list">Singly-linked List</a></li>
</ul>
</li>
<li class="toc-h1 nav-item toc-entry"><a class="reference internal nav-link" href="#i-matrix">I) Matrix</a><ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#matrix-x-simulation">Matrix x Simulation</a></li>
</ul>
</li>
</ul>

  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Jonny, assisted by Tom
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2023.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>