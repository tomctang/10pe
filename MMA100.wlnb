{
 "cells": [
  {
   "kind": 1,
   "value": "# Mathematica\r\n## Problems 1-50",
   "languageId": "markdown",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 26 *)\r\n(* learn 4 functions: \r\n    Association[]\r\n    Module[]\r\n    KeyExistsQ[]\r\n    Mod[] *)\r\ncycleLength[d_] := Module[{rems = Association[], num = 1, pos = 1},\r\n  While[! KeyExistsQ[rems, num] && num != 0,\r\n    rems[num] = pos;\r\n    num = Mod[10 num, d];\r\n    pos++   ];\r\n  If[num == 0, 0, pos - rems[num]]];\r\n\r\nSortBy[Range[888, 999], cycleLength]\r\ncycleLength[983]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 31 Coin Sums: use graph traversal (DFS) with memoization*)\r\n(* learn functions:\r\n    ClearAll[] \r\n    Memoization(:= ... =): store results to avoid recalculating for the same pair\r\n    Table[]: loop over each coin in validCoins *)\r\nClearAll[graphSearchWays];\r\nvalidCoins = {1, 2, 5, 10, 20, 50, 100, 200};\r\ngraphSearchWays[n_, maxCoin_] := graphSearchWays[n, maxCoin] =\r\n  If[n == 0, \r\n          1, \r\n   Total[Table[If[coin <= maxCoin && coin <= n, \r\n                graphSearchWays[n - coin, coin], \r\n                  0], {coin, validCoins}]]];\r\n\r\ngraphSearchWays[200, 200] (*calculate n of total pairs*)\r\nTreeForm[ (*see logic structure*)\r\n  If[n == 0, 1, \r\n  Total[Table[If[coin <= maxCoin && coin <= n, \r\n              graphSearchWays[n - coin, coin], \r\n              0], {coin, validCoins}]]]]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 32 Pandigital Products\r\n    1) memoization \r\n    2) form number from digits\r\n    *)\r\nnum = {1, 2, 3, 4, 5, 6, 7, 8, 9};\r\n\r\nnumSearch[] := numSearch[] =\r\n    Total[Table[If[multiplicand*multiplier == product, \r\n\r\n        Fold[10#1 + #2 &,  ]\r\n                numSearch[num - dig, dig], 0],  {dig, num}\r\n]]\r\nnumSearch[]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(*35 Circular Sums*) \r\nrotations[n_Integer] := Module[{digits = IntegerDigits[n]},\r\n  FromDigits /@ NestList[RotateLeft, digits, Length[digits] - 1]]\r\n\r\nisCircularPrime[n_Integer] := AllTrue[rotations[n], PrimeQ] (*if all rotations of a number are prime*)\r\ncircularPrimes = Select[Range[2, 999999], isCircularPrime]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 38 Pandigital Multiples\r\n    already presented (1,2,3) and (1,2,3,4,5)->918273645,(1,2,3,4,5,6,7,8,9)->123456789,calculated 3 options and n>1\r\n    left 2 options: (1,2,3,4,5,6,7) (1,2,3,4,5,6,7,8) *)\r\n(* (1,2) *1=****, *2=1****,\r\n (1,2,3,4) *1=**, *2=**, *3=**, *4=***,\r\n  (1,2,3,4,5,6) *1=*, *2=*, *3=*, *4=**, *5=**, *6=**,\r\n   (1,2,3,4,5,6,7) and (1,2,3,4,5,6,7,8) not possible*)\r\nSelect[Range[5000, 9999], \r\n  Function[n, \r\n    Length[Union[IntegerDigits[n], IntegerDigits[2 n]]] == 9 && \r\n    1000 <= 2 n < 100000\r\n  ]\r\n]\r\nSelect[Range[10, 99], Function[n, Length[Union[IntegerDigits[n #]] & /@ Range[4]]] == 9]\r\nSelect[Range[1, 100], \r\n  Function[n, \r\n    Length[Union[IntegerDigits[n], IntegerDigits[6 n]]] == 9 && \r\n    1 <= 6 n < 100000\r\n  ]\r\n]\r\nSelect[Range[100,1000], \r\n  Function[n, \r\n    Length[Union[IntegerDigits[n], IntegerDigits[3 n]]] == 9 && \r\n    1 <= 3 n < 100000\r\n  ]\r\n]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 45 Triangular, Pentagonal, and Hexagonal \r\n    what I can learn?\r\n    1) defining series \r\n    2) finding common items in lists \r\n    Faster Method???*)\r\n\r\nisTriangular[n_Integer] := Module[{k},\r\n  k = (-1 + Sqrt[1 + 8 n]) / 2;\r\n  IntegerQ[k]\r\n]\r\n\r\nisPentagonal[n_Integer] := Module[{k},\r\n  k = (1 + Sqrt[1 + 24 n]) / 6;\r\n  IntegerQ[k]\r\n]\r\n\r\nisHexagonal[n_Integer] := Module[{k},\r\n  k = (1 + Sqrt[1 + 8 n]) / 4;\r\n  IntegerQ[k]\r\n]\r\n\r\n(* Example usage *)\r\nisTriangularPentagonalHexagonal[n_]:=isTriangular[n]&&isPentagonal[n]&&isHexagonal[n]\r\nlst=Table[isTriangularPentagonalHexagonal[n],{n,50000000,60000000}];\r\nCount[lst,True]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 47 Distinct Primes Factors*)\r\nlst=Table[FactorInteger[n],{n,134040,134050}];\r\nlst1=Length/@lst;\r\nans=Select[Range[Length[lst1]],lst1[[#]]==4&];\r\nans1=Select[Range[3,Length[ans]],ans[[#]]==ans[[#-3]]+3&]\r\nans\r\n(* learn 5 functions:\r\n    Table[]\r\n    Length[]\r\n    FactorInteger[]\r\n    Select[]\r\n    Range[]*)",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "matrix = {\r\n  {7, 53, 183, 439, 863, 497, 383, 563, 79, 973, 287, 63, 343, 169, 583},\r\n  {627, 343, 773, 959, 943, 767, 473, 103, 699, 303, 957, 703, 583, 639, 913},\r\n  {447, 283, 463, 29, 23, 487, 463, 993, 119, 883, 327, 493, 423, 159, 743},\r\n  {217, 623, 3, 399, 853, 407, 103, 983, 89, 463, 290, 516, 212, 462, 350},\r\n  {960, 376, 682, 962, 300, 780, 486, 502, 912, 800, 250, 346, 172, 812, 350},\r\n  {870, 456, 192, 162, 593, 473, 915, 45, 989, 873, 823, 965, 425, 329, 803},\r\n  {973, 965, 905, 919, 133, 673, 665, 235, 509, 613, 673, 815, 165, 992, 326},\r\n  {322, 148, 972, 962, 286, 255, 941, 541, 265, 323, 925, 281, 601, 95, 973},\r\n  {445, 721, 11, 525, 473, 65, 511, 164, 138, 672, 18, 428, 154, 448, 848},\r\n  {414, 456, 310, 312, 798, 104, 566, 520, 302, 248, 694, 976, 430, 392, 198},\r\n  {184, 829, 373, 181, 631, 101, 969, 613, 840, 740, 778, 458, 284, 760, 390},\r\n  {821, 461, 843, 513, 17, 901, 711, 993, 293, 157, 274, 94, 192, 156, 574},\r\n  {34, 124, 4, 878, 450, 476, 712, 914, 838, 669, 875, 299, 823, 329, 699},\r\n  {815, 559, 813, 459, 522, 788, 168, 586, 966, 232, 308, 833, 251, 631, 107},\r\n  {813, 883, 451, 509, 615, 77, 281, 613, 459, 205, 380, 274, 302, 35, 805}\r\n};\r\nmaxRowTotal = Max[Total /@ matrix]\r\nmaxColumnTotal=Max[Total /@ Transpose[matrix]]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 1,
   "value": "## Problems 51-100",
   "languageId": "markdown",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 65 Convergents of e *)\r\n",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 69 Totient Maximum, also called \\phi function*)\r\n(* seq = Table[ n/Length[Select[Range[n], CoprimeQ[#, n] == True &]]\r\n             , {n, 10}] ;   pretty slow  *)\r\nseq = Table[ n/EulerPhi[n] , {n, 1000000} ];\r\nPosition[seq, Max[seq]]\r\nMax[seq]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 1,
   "value": "欧拉函数 Euler's Totient Function has a general formulas as below, $p_i$ is all of the coprime of x, where x is a positive integer.\r\n$$\\phi(x)=x\\prod_{i=1}^n(1-\\frac{1}{p_i})$$",
   "languageId": "markdown",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 71 Ordered Fractions \r\n    Table[] gen [{numerator}, {denominator}]\r\n    Floor[] gen greatest integer <= d*target\r\n    Select[] and MaximalBy[] 结构都是 list + function\r\n    [[2]] the 2nd item, #[[2]] the 2nd input of the function \r\n    *)\r\ntarget = 3/7;\r\nMaximalBy[Select[  Table[ {Floor[d*target], d}, {d, 2, 1000000} ], \r\n                          #[[1]]/#[[2]] < target & ], \r\n         #[[1]]/#[[2]] & ]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 80 Square Root Digital Expansion*)\r\nnumberDigits = RealDigits[Sqrt[2], 10, 100][[1]]\r\nlst=Complement[Range[1, 99], Table[n^2, {n, 1, Floor[Sqrt[99]]}]];\r\ntotalNumberDigits=Table[RealDigits[Sqrt[i], 10, 100][[1]],{i,lst}];\r\nlst1={{1,2,3,4,5},{6,7,8,9,10}};\r\nTotal[Total[lst1]]\r\nTotal[Total[totalNumberDigits]]\r\n(* learn 3 functions:\r\n    RealDigits[] give a list of len digit\r\n    Complement[] after excluding the subsequent lists, the complement from the first list \r\n    Total[] *)",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 99 \r\n   base^exponent =e^[exponent⋅log(base)]\r\n   [[2]] denotes the 2nd item in {{1,2},{1,2}} \r\n    *)\r\ndata = Import[\"https://projecteuler.net/resources/documents/0099_base_exp.txt\", \"CSV\"];\r\nnew = Map[#[[2]] * Log[#[[1]]] &, data];\r\nPosition[new, Max[new]]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 1,
   "value": "## Problems 101-200",
   "languageId": "markdown",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 125 Palindromic Sums *)\r\n(* add Boole[] to count number of times when <10^8 *)\r\n(* learnt functions:\r\n    Accumulate[]\r\n    AnyTrue[{},test] true if any input passes the test\r\n    MemberQ[{},___] true if any element in list is ___\r\n    Module[]??? *)\r\nisSumOfConsecutiveSquares[n_Integer] := \r\n Module[{maxK, sumsOfSquares},\r\n  maxK = Floor[Sqrt[n]];\r\n\r\n  (* Generate cumulative sums of consecutive squares starting from each k *)\r\n  sumsOfSquares = Table[\r\n    Accumulate[Table[(k + i)^2, {i, 0, maxK - k}]],\r\n    {k, 1, maxK}\r\n  ];\r\n\r\n  (* Check if any sum sequence contains n with more than one term *)\r\n  AnyTrue[sumsOfSquares, MemberQ[#, n] && Length[#] > 1 &]\r\n]\r\n\r\nisSumSquaresPalindromic[n_Integer]:=isSumOfConsecutiveSquares[n]&&PalindromeQ[n]\r\nlst=Table[isSumSquaresPalindromic[n],{n,2,9999}];\r\nCount[lst,True]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 162 Hexadecimal Numbers *)\r\nlst=Table[(n-1)*Factorial[n-1]/Factorial[n-3]*(14^(n-3)),{n,3,16}];\r\nlst1=Table[(n-1)*Factorial[n-1]/Factorial[n-3]*(16^(n-3)),{n,3,16}];\r\nn=(Total[lst1]-Total[lst])/2;\r\nn=\r\nBaseForm[Total[lst]+n,16]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "14*Factorial[14]/Factorial[12]\r\n15*Factorial[15]/Factorial[13]\r\n2*Factorial[2]/Factorial[0]*16^0",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "0123456789ABCDEF\r\n[1,A,0,0,0,0,0,0,0,0,0,0,0,0,0,0]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* 187 Semiprimes \r\n    Q: the code takes 11min, faster??? *)\r\nTotal[Table[ \r\n            Boole[ Total[FactorInteger[n]][[2]] == 2 ]\r\n            , {n,3,99999999} ] \r\n    ]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "(* speed up but wrong answer ?? - add {{_,2}} *)\r\n(* takes >11 min??? *)\r\nCount[ FactorInteger /@ Range[3, 10^8-1] \r\n      ,{{_, 1},{_, 1}} | {{_,2}}\r\n      ]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "lst=Table[ \r\n    Boole[ Length[ FactorInteger[n] ]==2 ],\r\n    {n,3,30}]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  },
  {
   "kind": 2,
   "value": "lst={{2,5},{3,1}};\r\nTotal[lst][[2]]",
   "languageId": "wolfram",
   "outputs": [],
   "metadata": {},
   "executionSummary": {}
  }
 ]
}